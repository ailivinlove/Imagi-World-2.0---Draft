<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Imagi-World 2.0 — Complete 62 Reasoning Types</title>
<style>
  :root{
    --bg:#0b132b;--panel:#1c2541;--ink:#e0e6f3;--accent:#5bc0be;--warn:#ff6b6b;--ok:#2ecc71;--muted:#94a3b8
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
  header{padding:20px 16px;text-align:center;border-bottom:1px solid #223}
  h1{margin:0;font-size:clamp(20px,3vw,28px)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:1fr;gap:16px}
  @media(min-width:880px){.grid{grid-template-columns:360px 1fr}}
  .card{background:var(--panel);border:1px solid #2a335a;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
  .pad{padding:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
  label{display:block;margin:8px 0 4px}
  label span{color:var(--muted);font-size:.9rem}
  input[type=range]{width:100%}
  input[type=number]{width:96px;padding:8px;border-radius:8px;border:1px solid #334;background:#0f1835;color:var(--ink)}
  button{cursor:pointer;border:0;border-radius:10px;padding:10px 14px;font-weight:700}
  .btn{background:var(--accent);color:#062025}
  .btn.secondary{background:#324063;color:#cbd5e1}
  .btn.danger{background:#c0392b;color:white}
  .btn.ghost{background:transparent;border:1px solid #3a466b;color:#cbd5e1}
  .status{font-size:1.1rem;margin:.5rem 0;color:#cbd5e1;min-height:2em}
  .premise-container{background:#0d1736;border:1px solid #334;border-radius:10px;padding:12px;margin:12px 0;min-height:120px}
  .premise{font-size:1.3rem;line-height:1.5;margin:6px 0;color:#e0e6f3}
  .premise-number{color:var(--accent);font-weight:bold;margin-right:8px}
  .bigbtns{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .bigbtns button{padding:18px 16px;font-size:1.2rem}
  .bigbtns .yes{background:var(--ok);color:#052b16}
  .bigbtns .no{background:var(--warn);color:#2b0505}
  .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:10px;margin-top:12px}
  .stat{background:#0d1736;border:1px solid #223;border-radius:10px;padding:10px;text-align:center}
  .kpi{font-size:1.5rem;font-weight:800;color:var(--accent)}
  .log{max-height:300px;overflow:auto;background:#081026;border:1px dashed #2a335a;border-radius:10px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.9rem}
  details{background:#101a39;border-radius:10px;margin-top:10px}
  summary{cursor:pointer;padding:10px 12px;border-bottom:1px solid #202a56}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.92rem}
  .timer-bar{height:6px;background:#223;border-radius:3px;margin:10px 0;position:relative;overflow:hidden}
  .timer-progress{height:100%;background:var(--accent);width:100%;transition:width linear}
</style>
</head>
<body>
  <header>
    <h1>Imagi-World 2.0 · Complete 62 Reasoning Types</h1>
    <p class="mono">Novel premises generated across all 62 logical reasoning patterns. N-back matching based on logical structure.</p>
  </header>
  <div class="wrap">
    <div class="grid">
      <section class="card pad" aria-label="controls">
        <h2 style="margin-top:0">Session Configuration</h2>
        
        <label for="nback">N-Back Level <span id="nbackV">2</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="2" />

        <label for="sec">Seconds per Trial <span id="secV">10</span></label>
        <div class="row">
          <input id="sec" type="range" min="3" max="30" step="0.5" value="10" />
          <input id="secNum" type="number" min="3" max="30" step="0.5" value="10" />
        </div>

        <label for="premises">Premises per Trial <span id="premisesV">1</span></label>
        <div class="row">
          <input id="premises" type="range" min="1" max="5" step="1" value="1" />
          <input id="premisesNum" type="number" min="1" max="5" step="1" value="1" />
        </div>

        <label for="trials">Trials per Session <span id="trialsV">30</span></label>
        <div class="row">
          <input id="trials" type="range" min="5" max="100" step="1" value="30" />
          <input id="trialsNum" type="number" min="5" max="1000" step="1" value="30" />
        </div>

        <label for="matchRate">Target Match Rate % <span id="matchRateV">25</span></label>
        <input id="matchRate" type="range" min="10" max="50" step="5" value="25" />

        <div class="row" style="margin-top:16px">
          <button id="start" class="btn">START</button>
          <button id="stop" class="btn danger" disabled>STOP</button>
          <button id="reset" class="btn secondary">Reset Stats</button>
        </div>
        <div class="row">
          <button id="download" class="btn ghost">Export Session Log</button>
        </div>
      </section>

      <section class="card pad" aria-live="polite">
        <div class="status" id="status">Ready to begin. Press START to generate premises.</div>
        <div class="timer-bar"><div class="timer-progress" id="timerBar"></div></div>
        <div class="premise-container" id="premiseContainer">
          <div class="premise" id="premise">Premises will appear here...</div>
        </div>
        <div class="bigbtns">
          <button id="btnMatch" class="yes" disabled>MATCH</button>
          <button id="btnNoMatch" class="no" disabled>NO MATCH</button>
        </div>
        <div class="stats">
          <div class="stat"><div>Trial</div><div class="kpi" id="kTrial">0</div></div>
          <div class="stat"><div>Score</div><div class="kpi" id="kScore">0</div></div>
          <div class="stat"><div>Accuracy</div><div class="kpi" id="kAcc">—</div></div>
          <div class="stat"><div>Hits</div><div class="kpi" id="kHits">0</div></div>
          <div class="stat"><div>Misses</div><div class="kpi" id="kMisses">0</div></div>
          <div class="stat"><div>Omissions</div><div class="kpi" id="kOmit">0</div></div>
        </div>
      </section>
    </div>

    <section class="card pad">
      <details open>
        <summary><strong>How N-Back Logical Matching Works</strong></summary>
        <div class="pad">
          <p>Each trial presents one or more premises based on the 62 reasoning types. An n-back match occurs when the <strong>logical structure</strong> of the current trial matches the structure from n trials ago, NOT when premises are repeated.</p>
          <ul>
            <li><strong>Novel premises only:</strong> Every premise is completely unique - never repeated</li>
            <li><strong>Logical matching:</strong> Matches are based on reasoning patterns (e.g., modus ponens, contraposition)</li>
            <li><strong>62 reasoning types:</strong> Including circularity, modus ponens, tollens, syllogisms, bijections, etc.</li>
            <li><strong>Customizable:</strong> Adjust trial time and premises per trial for difficulty</li>
          </ul>
        </div>
      </details>
      <details>
        <summary><strong>Session Log</strong></summary>
        <div class="pad">
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </details>
    </section>
  </div>

<script>
(function(){
  // Core utilities
  const $ = sel => document.querySelector(sel);
  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const choice = arr => arr[rand(0, arr.length - 1)];
  const shuffle = arr => {
    const copy = [...arr];
    for(let i = copy.length - 1; i > 0; i--) {
      const j = rand(0, i);
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
  };
  const sample = (arr, k) => shuffle([...arr]).slice(0, k);

  // Premise generation helpers
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  const usedPremises = new Set();
  let letterIndex = 0;

  function getNextLetters(count) {
    const result = [];
    for(let i = 0; i < count; i++) {
      result.push(letters[letterIndex % 26]);
      letterIndex++;
    }
    return result;
  }

  // Logical connectives variations
  const IF_VARIANTS = ['If', 'When', 'Whenever', 'Given that', 'Assuming'];
  const THEN_VARIANTS = ['then', 'it follows that', 'consequently', 'therefore', 'thus'];
  const OR_VARIANTS = ['or', 'alternatively', 'otherwise', 'else'];
  const AND_VARIANTS = ['and', 'moreover', 'furthermore', 'also', 'additionally'];
  const NOT_VARIANTS = ['not', 'never', 'fails to be', 'is false'];
  const IMPLIES_VARIANTS = ['implies', 'leads to', 'results in', 'causes', 'entails'];

  // Relation types for spatial/hierarchical reasoning
  const ABOVE_RELATIONS = ['is above', 'is higher than', 'supersedes', 'dominates'];
  const BELOW_RELATIONS = ['is below', 'is lower than', 'is subordinate to', 'follows'];
  const BESIDE_RELATIONS = ['is beside', 'is adjacent to', 'is parallel to', 'aligns with'];
  
  // All 62 reasoning type generators
  const reasoningGenerators = {
    // Type 1: Circularity via drift
    1: () => {
      const [A, B, C] = getNextLetters(3);
      const implies = choice(IMPLIES_VARIANTS);
      const premise = `${A} ${implies} ${B}; ${B} ${implies} some ${C}; some ${C} ${implies} ${A}`;
      return {
        premise,
        logicType: 'circularity_drift',
        structure: 'A→B→∃C→A'
      };
    },

    // Type 2: Modus ponens with decoy
    2: () => {
      const [D, E, F] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${D} ${thenWord} ${E}; either ${F} ${orWord} ${D}; ${F} is ${notWord}`;
      return {
        premise,
        logicType: 'modus_ponens_decoy',
        structure: '(D→E)∧(F∨D)∧¬F'
      };
    },

    // Type 3: Syllogism variant
    3: () => {
      const [G, H, I] = getNextLetters(3);
      const premise = `All ${G} are ${H}; all ${H} are ${I}; therefore all ${G} are ${I}`;
      return {
        premise,
        logicType: 'syllogism_transitive',
        structure: '∀G→H∧∀H→I⇒∀G→I'
      };
    },

    // Type 4: Existential generalization blocked
    4: () => {
      const [J, K] = getNextLetters(2);
      const premise = `Some ${J} are ${K}; but not all ${J} are ${K}; existence without universality`;
      return {
        premise,
        logicType: 'existential_blocked',
        structure: '∃J∧K∧¬∀J→K'
      };
    },

    // Type 5: Two premises both needed
    5: () => {
      const [L, M, N, O] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${L} ${andWord} ${M} ${thenWord} ${N}; ${L} holds; ${M} holds; therefore ${N}`;
      return {
        premise,
        logicType: 'conjunction_modus_ponens',
        structure: '((L∧M)→N)∧L∧M⇒N'
      };
    },

    // Type 6: Modus tollens
    6: () => {
      const [P, Q] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${P} ${thenWord} ${Q}; ${Q} is ${notWord}; therefore ${P} is ${notWord}`;
      return {
        premise,
        logicType: 'modus_tollens',
        structure: '(P→Q)∧¬Q⇒¬P'
      };
    },

    // Type 7: Contraposition
    7: () => {
      const [R, S] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${R} ${thenWord} ${S} is equivalent to ${ifWord} ${notWord} ${S} ${thenWord} ${notWord} ${R}`;
      return {
        premise,
        logicType: 'contraposition',
        structure: '(R→S)≡(¬S→¬R)'
      };
    },

    // Type 8: Hypothetical syllogism  
    8: () => {
      const [T, U, V] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${T} ${thenWord} ${U}; ${ifWord} ${U} ${thenWord} ${V}; therefore ${ifWord} ${T} ${thenWord} ${V}`;
      return {
        premise,
        logicType: 'hypothetical_syllogism',
        structure: '(T→U)∧(U→V)⇒(T→V)'
      };
    },

    // Type 9: Disjunctive syllogism
    9: () => {
      const [W, X] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Either ${W} ${orWord} ${X}; ${W} is ${notWord}; therefore ${X}`;
      return {
        premise,
        logicType: 'disjunctive_syllogism',
        structure: '(W∨X)∧¬W⇒X'
      };
    },

    // Type 10: Constructive dilemma
    10: () => {
      const [A, B, C, D] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${ifWord} ${A} ${thenWord} ${B}; ${ifWord} ${C} ${thenWord} ${D}; either ${A} ${orWord} ${C}; therefore either ${B} ${orWord} ${D}`;
      return {
        premise,
        logicType: 'constructive_dilemma',
        structure: '(A→B)∧(C→D)∧(A∨C)⇒(B∨D)'
      };
    },

    // Type 11: Biconditional introduction
    11: () => {
      const [E, F] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${E} ${thenWord} ${F}; ${ifWord} ${F} ${thenWord} ${E}; therefore ${E} if and only if ${F}`;
      return {
        premise,
        logicType: 'biconditional_intro',
        structure: '(E→F)∧(F→E)⇒(E↔F)'
      };
    },

    // Type 12: Universal instantiation
    12: () => {
      const [G, H] = getNextLetters(2);
      const premise = `All ${G} have property P; ${H} is a ${G}; therefore ${H} has property P`;
      return {
        premise,
        logicType: 'universal_instantiation',
        structure: '∀G(P)∧H∈G⇒P(H)'
      };
    },

    // Type 13: Existential instantiation
    13: () => {
      const [I, J] = getNextLetters(2);
      const premise = `Some ${I} are ${J}; let ${I}₀ be such an ${I}; then ${I}₀ is ${J}`;
      return {
        premise,
        logicType: 'existential_instantiation',
        structure: '∃I(J)⇒J(I₀)'
      };
    },

    // Type 14: Double negation
    14: () => {
      const [K] = getNextLetters(1);
      const notWord = choice(NOT_VARIANTS);
      const premise = `It is ${notWord} the case that ${K} is ${notWord}; therefore ${K} is true`;
      return {
        premise,
        logicType: 'double_negation',
        structure: '¬¬K⇒K'
      };
    },

    // Type 15: De Morgan's Law (AND)
    15: () => {
      const [L, M] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${notWord} (${L} ${andWord} ${M}) is equivalent to (${notWord} ${L}) ${orWord} (${notWord} ${M})`;
      return {
        premise,
        logicType: 'de_morgan_and',
        structure: '¬(L∧M)≡(¬L∨¬M)'
      };
    },

    // Type 16: De Morgan's Law (OR)
    16: () => {
      const [N, O] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${notWord} (${N} ${orWord} ${O}) is equivalent to (${notWord} ${N}) ${andWord} (${notWord} ${O})`;
      return {
        premise,
        logicType: 'de_morgan_or',
        structure: '¬(N∨O)≡(¬N∧¬O)'
      };
    },

    // Type 17: Absorption
    17: () => {
      const [P, Q] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const premise = `${ifWord} ${P} ${thenWord} ${Q}; therefore ${ifWord} ${P} ${thenWord} (${P} ${andWord} ${Q})`;
      return {
        premise,
        logicType: 'absorption',
        structure: '(P→Q)⇒(P→(P∧Q))'
      };
    },

    // Type 18: Simplification
    18: () => {
      const [R, S] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const premise = `${R} ${andWord} ${S}; therefore ${R}`;
      return {
        premise,
        logicType: 'simplification',
        structure: '(R∧S)⇒R'
      };
    },

    // Type 19: Addition
    19: () => {
      const [T, U] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const premise = `${T} is true; therefore ${T} ${orWord} ${U}`;
      return {
        premise,
        logicType: 'addition',
        structure: 'T⇒(T∨U)'
      };
    },

    // Type 20: Conjunction
    20: () => {
      const [V, W] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const premise = `${V} is true; ${W} is true; therefore ${V} ${andWord} ${W}`;
      return {
        premise,
        logicType: 'conjunction',
        structure: 'V∧W⇒(V∧W)'
      };
    },

    // Type 21: Destructive dilemma
    21: () => {
      const [A, B, C, D] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${A} ${thenWord} ${B}; ${ifWord} ${C} ${thenWord} ${D}; either ${notWord} ${B} ${orWord} ${notWord} ${D}; therefore either ${notWord} ${A} ${orWord} ${notWord} ${C}`;
      return {
        premise,
        logicType: 'destructive_dilemma',
        structure: '(A→B)∧(C→D)∧(¬B∨¬D)⇒(¬A∨¬C)'
      };
    },

    // Type 22: Material implication
    22: () => {
      const [E, F] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${E} ${thenWord} ${F} is equivalent to ${notWord} ${E} ${orWord} ${F}`;
      return {
        premise,
        logicType: 'material_implication',
        structure: '(E→F)≡(¬E∨F)'
      };
    },

    // Type 23: Exportation
    23: () => {
      const [G, H, I] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} (${G} ${andWord} ${H}) ${thenWord} ${I} is equivalent to ${ifWord} ${G} ${thenWord} (${ifWord} ${H} ${thenWord} ${I})`;
      return {
        premise,
        logicType: 'exportation',
        structure: '((G∧H)→I)≡(G→(H→I))'
      };
    },

    // Type 24: Spatial above/below transitivity
    24: () => {
      const [J, K, L] = getNextLetters(3);
      const above = choice(ABOVE_RELATIONS);
      const premise = `${J} ${above} ${K}; ${K} ${above} ${L}; therefore ${J} ${above} ${L}`;
      return {
        premise,
        logicType: 'spatial_transitivity',
        structure: 'Above(J,K)∧Above(K,L)⇒Above(J,L)'
      };
    },

    // Type 25: Quantifier negation (universal)
    25: () => {
      const [M, N] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${notWord} all ${M} are ${N} is equivalent to some ${M} are ${notWord} ${N}`;
      return {
        premise,
        logicType: 'quantifier_negation_universal',
        structure: '¬∀M(N)≡∃M(¬N)'
      };
    },

    // Type 26: Quantifier negation (existential)
    26: () => {
      const [O, P] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${notWord} some ${O} are ${P} is equivalent to all ${O} are ${notWord} ${P}`;
      return {
        premise,
        logicType: 'quantifier_negation_existential',
        structure: '¬∃O(P)≡∀O(¬P)'
      };
    },

    // Type 27: Chain rule
    27: () => {
      const [Q, R, S, T] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${Q} ${thenWord} ${R}; ${ifWord} ${R} ${thenWord} ${S}; ${ifWord} ${S} ${thenWord} ${T}; therefore ${ifWord} ${Q} ${thenWord} ${T}`;
      return {
        premise,
        logicType: 'chain_rule',
        structure: '(Q→R)∧(R→S)∧(S→T)⇒(Q→T)'
      };
    },

    // Type 28: Proof by contradiction setup
    28: () => {
      const [U, V] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Assume ${notWord} ${U}; this leads to ${V} and ${notWord} ${V}; therefore ${U}`;
      return {
        premise,
        logicType: 'proof_by_contradiction',
        structure: '(¬U→(V∧¬V))⇒U'
      };
    },

    // Type 29: Inclusive vs exclusive OR
    29: () => {
      const [W, X] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const premise = `Either ${W} ${orWord} ${X} (inclusive); both can be true; versus either ${W} ${orWord} ${X} (exclusive); exactly one is true`;
      return {
        premise,
        logicType: 'inclusive_exclusive_or',
        structure: '(W∨X)_inc vs (W⊕X)_exc'
      };
    },

    // Type 30: Transposition
    30: () => {
      const [Y, Z] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${Y} ${thenWord} ${Z}; therefore ${ifWord} ${notWord} ${Z} ${thenWord} ${notWord} ${Y}`;
      return {
        premise,
        logicType: 'transposition',
        structure: '(Y→Z)⇒(¬Z→¬Y)'
      };
    },

    // Type 31: Reductio ad absurdum
    31: () => {
      const [A, B] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Suppose ${A}; from ${A} we derive ${B}; but ${B} is absurd; therefore ${notWord} ${A}`;
      return {
        premise,
        logicType: 'reductio_ad_absurdum',
        structure: '(A→B)∧(B=⊥)⇒¬A'
      };
    },

    // Type 32: Law of excluded middle
    32: () => {
      const [C] = getNextLetters(1);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Either ${C} ${orWord} ${notWord} ${C}; no third option exists`;
      return {
        premise,
        logicType: 'excluded_middle',
        structure: 'C∨¬C'
      };
    },

    // Type 33: Law of non-contradiction
    33: () => {
      const [D] = getNextLetters(1);
      const andWord = choice(AND_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${D} ${andWord} ${notWord} ${D} cannot both be true`;
      return {
        premise,
        logicType: 'non_contradiction',
        structure: '¬(D∧¬D)'
      };
    },

    // Type 34: Identity law
    34: () => {
      const [E] = getNextLetters(1);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${E} ${thenWord} ${E}; self-implication always holds`;
      return {
        premise,
        logicType: 'identity',
        structure: 'E→E'
      };
    },

    // Type 35: Commutative (AND)
    35: () => {
      const [F, G] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const premise = `${F} ${andWord} ${G} is equivalent to ${G} ${andWord} ${F}`;
      return {
        premise,
        logicType: 'commutative_and',
        structure: '(F∧G)≡(G∧F)'
      };
    },

    // Type 36: Commutative (OR)
    36: () => {
      const [H, I] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const premise = `${H} ${orWord} ${I} is equivalent to ${I} ${orWord} ${H}`;
      return {
        premise,
        logicType: 'commutative_or',
        structure: '(H∨I)≡(I∨H)'
      };
    },

    // Type 37: Associative (AND)
    37: () => {
      const [J, K, L] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const premise = `(${J} ${andWord} ${K}) ${andWord} ${L} equals ${J} ${andWord} (${K} ${andWord} ${L})`;
      return {
        premise,
        logicType: 'associative_and',
        structure: '((J∧K)∧L)≡(J∧(K∧L))'
      };
    },

    // Type 38: Associative (OR)
    38: () => {
      const [M, N, O] = getNextLetters(3);
      const orWord = choice(OR_VARIANTS);
      const premise = `(${M} ${orWord} ${N}) ${orWord} ${O} equals ${M} ${orWord} (${N} ${orWord} ${O})`;
      return {
        premise,
        logicType: 'associative_or',
        structure: '((M∨N)∨O)≡(M∨(N∨O))'
      };
    },

    // Type 39: Distributive (AND over OR)
    39: () => {
      const [P, Q, R] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${P} ${andWord} (${Q} ${orWord} ${R}) equals (${P} ${andWord} ${Q}) ${orWord} (${P} ${andWord} ${R})`;
      return {
        premise,
        logicType: 'distributive_and_or',
        structure: 'P∧(Q∨R)≡(P∧Q)∨(P∧R)'
      };
    },

    // Type 40: Distributive (OR over AND)
    40: () => {
      const [S, T, U] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${S} ${orWord} (${T} ${andWord} ${U}) equals (${S} ${orWord} ${T}) ${andWord} (${S} ${orWord} ${U})`;
      return {
        premise,
        logicType: 'distributive_or_and',
        structure: 'S∨(T∧U)≡(S∨T)∧(S∨U)'
      };
    },

    // Type 41: Idempotent (AND)
    41: () => {
      const [V] = getNextLetters(1);
      const andWord = choice(AND_VARIANTS);
      const premise = `${V} ${andWord} ${V} equals ${V}`;
      return {
        premise,
        logicType: 'idempotent_and',
        structure: '(V∧V)≡V'
      };
    },

    // Type 42: Idempotent (OR)
    42: () => {
      const [W] = getNextLetters(1);
      const orWord = choice(OR_VARIANTS);
      const premise = `${W} ${orWord} ${W} equals ${W}`;
      return {
        premise,
        logicType: 'idempotent_or',
        structure: '(W∨W)≡W'
      };
    },

    // Type 43: Resolution
    43: () => {
      const [X, Y, Z] = getNextLetters(3);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${X} ${orWord} ${Y}; ${notWord} ${X} ${orWord} ${Z}; therefore ${Y} ${orWord} ${Z}`;
      return {
        premise,
        logicType: 'resolution',
        structure: '(X∨Y)∧(¬X∨Z)⇒(Y∨Z)'
      };
    },

    // Type 44: Universal modus ponens
    44: () => {
      const [A, B, C] = getNextLetters(3);
      const premise = `For all x, if x is ${A} then x is ${B}; ${C} is ${A}; therefore ${C} is ${B}`;
      return {
        premise,
        logicType: 'universal_modus_ponens',
        structure: '∀x(A(x)→B(x))∧A(C)⇒B(C)'
      };
    },

    // Type 45: Existential modus tollens
    45: () => {
      const [D, E] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `If something is ${D} then it is ${E}; nothing is ${E}; therefore nothing is ${D}`;
      return {
        premise,
        logicType: 'existential_modus_tollens',
        structure: '∀x(D(x)→E(x))∧¬∃x(E(x))⇒¬∃x(D(x))'
      };
    },

    // Type 46: Particular affirmative
    46: () => {
      const [F, G] = getNextLetters(2);
      const premise = `Some ${F} are ${G}; at least one ${F} has property ${G}`;
      return {
        premise,
        logicType: 'particular_affirmative',
        structure: '∃x(F(x)∧G(x))'
      };
    },

    // Type 47: Particular negative
    47: () => {
      const [H, I] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Some ${H} are ${notWord} ${I}; at least one ${H} lacks property ${I}`;
      return {
        premise,
        logicType: 'particular_negative',
        structure: '∃x(H(x)∧¬I(x))'
      };
    },

    // Type 48: Universal affirmative
    48: () => {
      const [J, K] = getNextLetters(2);
      const premise = `All ${J} are ${K}; every ${J} has property ${K}`;
      return {
        premise,
        logicType: 'universal_affirmative',
        structure: '∀x(J(x)→K(x))'
      };
    },

    // Type 49: Universal negative
    49: () => {
      const [L, M] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `No ${L} are ${M}; all ${L} are ${notWord} ${M}`;
      return {
        premise,
        logicType: 'universal_negative',
        structure: '∀x(L(x)→¬M(x))'
      };
    },

    // Type 50: Subalternation
    50: () => {
      const [N, O] = getNextLetters(2);
      const premise = `All ${N} are ${O}; therefore some ${N} are ${O}`;
      return {
        premise,
        logicType: 'subalternation',
        structure: '∀x(N(x)→O(x))⇒∃x(N(x)∧O(x))'
      };
    },

    // Type 51: Conversion (simple)
    51: () => {
      const [P, Q] = getNextLetters(2);
      const premise = `Some ${P} are ${Q}; therefore some ${Q} are ${P}`;
      return {
        premise,
        logicType: 'conversion_simple',
        structure: '∃x(P(x)∧Q(x))⇒∃x(Q(x)∧P(x))'
      };
    },

    // Type 52: Conversion (per accidens)
    52: () => {
      const [R, S] = getNextLetters(2);
      const premise = `All ${R} are ${S}; therefore some ${S} are ${R}`;
      return {
        premise,
        logicType: 'conversion_per_accidens',
        structure: '∀x(R(x)→S(x))⇒∃x(S(x)∧R(x))'
      };
    },

    // Type 53: Obversion
    53: () => {
      const [T, U] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `All ${T} are ${U}; therefore no ${T} are ${notWord} ${U}`;
      return {
        premise,
        logicType: 'obversion',
        structure: '∀x(T(x)→U(x))⇒∀x(T(x)→¬¬U(x))'
      };
    },

    // Type 54: Contraposition (categorical)
    54: () => {
      const [V, W] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `All ${V} are ${W}; therefore all ${notWord} ${W} are ${notWord} ${V}`;
      return {
        premise,
        logicType: 'contraposition_categorical',
        structure: '∀x(V(x)→W(x))⇒∀x(¬W(x)→¬V(x))'
      };
    },

    // Type 55: Square of opposition - contradictory
    55: () => {
      const [X, Y] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `All ${X} are ${Y} contradicts some ${X} are ${notWord} ${Y}`;
      return {
        premise,
        logicType: 'square_contradictory',
        structure: '∀x(X(x)→Y(x))⊥∃x(X(x)∧¬Y(x))'
      };
    },

    // Type 56: Square of opposition - contrary
    56: () => {
      const [Z, A] = getNextLetters(2);
      const premise = `All ${Z} are ${A} and no ${Z} are ${A} cannot both be true`;
      return {
        premise,
        logicType: 'square_contrary',
        structure: '¬(∀x(Z(x)→A(x))∧∀x(Z(x)→¬A(x)))'
      };
    },

    // Type 57: Square of opposition - subcontrary
    57: () => {
      const [B, C] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Some ${B} are ${C} or some ${B} are ${notWord} ${C} must be true`;
      return {
        premise,
        logicType: 'square_subcontrary',
        structure: '∃x(B(x)∧C(x))∨∃x(B(x)∧¬C(x))'
      };
    },

    // Type 58: Barbara syllogism
    58: () => {
      const [D, E, F] = getNextLetters(3);
      const premise = `All ${E} are ${F}; all ${D} are ${E}; therefore all ${D} are ${F}`;
      return {
        premise,
        logicType: 'barbara_syllogism',
        structure: '∀x(E(x)→F(x))∧∀x(D(x)→E(x))⇒∀x(D(x)→F(x))'
      };
    },

    // Type 59: Celarent syllogism
    59: () => {
      const [G, H, I] = getNextLetters(3);
      const premise = `No ${H} are ${I}; all ${G} are ${H}; therefore no ${G} are ${I}`;
      return {
        premise,
        logicType: 'celarent_syllogism',
        structure: '∀x(H(x)→¬I(x))∧∀x(G(x)→H(x))⇒∀x(G(x)→¬I(x))'
      };
    },

    // Type 60: Darii syllogism
    60: () => {
      const [J, K, L] = getNextLetters(3);
      const premise = `All ${K} are ${L}; some ${J} are ${K}; therefore some ${J} are ${L}`;
      return {
        premise,
        logicType: 'darii_syllogism',
        structure: '∀x(K(x)→L(x))∧∃x(J(x)∧K(x))⇒∃x(J(x)∧L(x))'
      };
    },

    // Type 61: Exchange argument improvement
    61: () => {
      const [M, N] = getNextLetters(2);
      const premise = `Choose ${M} minimal under criterion P; if component X can be swapped for Y to improve, contradiction; therefore ${M} is optimal`;
      return {
        premise,
        logicType: 'exchange_argument',
        structure: 'minimal(M,P)∧(swap→better)⇒⊥∴optimal(M)'
      };
    },

    // Type 62: Bijection and inversion
    62: () => {
      const [O, P] = getNextLetters(2);
      const premise = `Mapping from ${O} to ${P} is one-to-one and onto; therefore inverse mapping from ${P} to ${O} exists uniquely`;
      return {
        premise,
        logicType: 'bijection_inversion',
        structure: 'bijection(O→P)⇒∃!inverse(P→O)'
      };
    }
  };

  // Session state
  const state = {
    n: 2,
    secondsPerTrial: 10,
    premisesPerTrial: 1,
    trials: 30,
    matchRate: 0.25,
    running: false,
    currentTrial: 0,
    score: 0,
    hits: 0,
    misses: 0,
    responses: 0,
    omissions: 0,
    schedule: [],
    history: [],
    timer: null,
    timerBar: null
  };

  // Generate unique premise
  function generateUniquePremise(typeId = null) {
    const maxAttempts = 100;
    for(let i = 0; i < maxAttempts; i++) {
      const id = typeId || rand(1, 62);
      const generator = reasoningGenerators[id];
      if(!generator) continue;
      
      const result = generator();
      result.typeId = id;
      
      // Ensure uniqueness
      if(!usedPremises.has(result.premise)) {
        usedPremises.add(result.premise);
        return result;
      }
    }
    // Fallback with timestamp
    const id = typeId || rand(1, 62);
    const result = reasoningGenerators[id]();
    result.typeId = id;
    result.premise += ` [${Date.now()}]`;
    usedPremises.add(result.premise);
    return result;
  }

  // Generate multiple premises for a trial
  function generateTrialPremises(count, matchData = null) {
    const premises = [];
    
    if(matchData) {
      // Generate matching logical structures
      for(let i = 0; i < count; i++) {
        const typeId = matchData[i % matchData.length].typeId;
        premises.push(generateUniquePremise(typeId));
      }
    } else {
      // Generate random premises
      for(let i = 0; i < count; i++) {
        premises.push(generateUniquePremise());
      }
    }
    
    return premises;
  }

  // Build match schedule
  function buildSchedule(n, trials, matchRate) {
    const schedule = new Array(trials).fill(false);
    for(let i = n; i < trials; i++) {
      schedule[i] = Math.random() < matchRate;
    }
    return schedule;
  }

  // Update UI statistics
  function updateStats() {
    $('#kTrial').textContent = state.currentTrial;
    $('#kScore').textContent = state.score;
    $('#kHits').textContent = state.hits;
    $('#kMisses').textContent = state.misses;
    $('#kOmit').textContent = state.omissions;
    
    const accuracy = state.responses > 0 
      ? Math.round(100 * state.hits / state.responses) + '%' 
      : '—';
    $('#kAcc').textContent = accuracy;
  }

  // Add log entry
  function addLog(message) {
    const log = $('#log');
    const time = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.textContent = `[${time}] ${message}`;
    log.insertBefore(entry, log.firstChild);
    
    // Keep log size manageable
    while(log.children.length > 50) {
      log.removeChild(log.lastChild);
    }
  }

  // Present trial
  function presentTrial() {
    if(!state.running) return;
    
    if(state.currentTrial >= state.trials) {
      stopSession();
      return;
    }

    const shouldMatch = state.schedule[state.currentTrial];
    let trialData;
    
    if(shouldMatch && state.currentTrial >= state.n) {
      // Generate matching premises based on n-back logical structure
      const matchTarget = state.history[state.currentTrial - state.n];
      trialData = generateTrialPremises(state.premisesPerTrial, matchTarget);
      addLog(`Trial ${state.currentTrial + 1}: N-back MATCH (types: ${trialData.map(d => d.typeId).join(',')})`);
    } else {
      // Generate new random premises
      trialData = generateTrialPremises(state.premisesPerTrial);
      addLog(`Trial ${state.currentTrial + 1}: New premises (types: ${trialData.map(d => d.typeId).join(',')})`);
    }
    
    state.history.push(trialData);
    
    // Display premises
    const container = $('#premiseContainer');
    container.innerHTML = '';
    trialData.forEach((data, index) => {
      const div = document.createElement('div');
      div.className = 'premise';
      div.innerHTML = `<span class="premise-number">${index + 1}.</span>${data.premise}`;
      container.appendChild(div);
    });
    
    // Update status
    const types = trialData.map(d => `Type ${d.typeId}`).join(', ');
    $('#status').textContent = `Trial ${state.currentTrial + 1} of ${state.trials} • ${types} • N-back: ${state.n}`;
    
    // Enable response buttons
    $('#btnMatch').disabled = false;
    $('#btnNoMatch').disabled = false;
    
    // Start timer
    startTimer();
  }

  // Timer management
  function startTimer() {
    clearTimeout(state.timer);
    clearInterval(state.timerBar);
    
    const timerBar = $('#timerBar');
    timerBar.style.width = '100%';
    timerBar.style.transition = 'none';
    
    setTimeout(() => {
      timerBar.style.transition = `width ${state.secondsPerTrial}s linear`;
      timerBar.style.width = '0%';
    }, 50);
    
    state.timer = setTimeout(() => {
      handleOmission();
    }, state.secondsPerTrial * 1000);
  }

  // Handle omission
  function handleOmission() {
    state.omissions++;
    state.responses++;
    
    const expected = state.schedule[state.currentTrial];
    const message = expected ? 'Time up! Expected: MATCH' : 'Time up! Expected: NO MATCH';
    $('#status').textContent = message;
    addLog(`Trial ${state.currentTrial + 1}: OMISSION (expected: ${expected ? 'MATCH' : 'NO MATCH'})`);
    
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    state.currentTrial++;
    updateStats();
    
    setTimeout(() => presentTrial(), 1000);
  }

  // Handle response
  function handleResponse(isMatch) {
    if(!state.running) return;
    
    clearTimeout(state.timer);
    $('#timerBar').style.width = '0%';
    
    const expected = state.schedule[state.currentTrial];
    const correct = (isMatch === expected);
    
    state.responses++;
    if(correct) {
      state.score++;
      state.hits++;
      $('#status').textContent = '✓ Correct!';
      $('#status').style.color = 'var(--ok)';
    } else {
      state.score--;
      state.misses++;
      $('#status').textContent = '✗ Incorrect';
      $('#status').style.color = 'var(--warn)';
    }
    
    addLog(`Trial ${state.currentTrial + 1}: Response: ${isMatch ? 'MATCH' : 'NO MATCH'}, Expected: ${expected ? 'MATCH' : 'NO MATCH'}, ${correct ? 'CORRECT' : 'INCORRECT'}`);
    
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    state.currentTrial++;
    updateStats();
    
    setTimeout(() => {
      $('#status').style.color = '';
      presentTrial();
    }, 1000);
  }

  // Start session
  function startSession() {
    // Reset state
    state.running = true;
    state.currentTrial = 0;
    state.score = 0;
    state.hits = 0;
    state.misses = 0;
    state.responses = 0;
    state.omissions = 0;
    state.history = [];
    usedPremises.clear();
    letterIndex = 0;
    
    // Build schedule
    state.schedule = buildSchedule(state.n, state.trials, state.matchRate);
    
    const matchCount = state.schedule.filter(Boolean).length;
    addLog(`Session started: ${state.trials} trials, n-back=${state.n}, ${state.premisesPerTrial} premises/trial, ${matchCount} matches scheduled`);
    
    // Update UI
    $('#start').disabled = true;
    $('#stop').disabled = false;
    $('#btnMatch').disabled = false;
    $('#btnNoMatch').disabled = false;
    
    updateStats();
    presentTrial();
  }

  // Stop session
  function stopSession() {
    state.running = false;
    clearTimeout(state.timer);
    
    $('#status').textContent = `Session complete! Final score: ${state.score}`;
    $('#start').disabled = false;
    $('#stop').disabled = true;
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    addLog(`Session ended: Score=${state.score}, Accuracy=${state.hits}/${state.responses}, Omissions=${state.omissions}`);
  }

  // Export log
  function exportLog() {
    const logData = state.history.map((trial, index) => {
      const types = trial.map(p => p.typeId).join(',');
      const structures = trial.map(p => p.structure).join(' | ');
      const premises = trial.map(p => p.premise).join(' || ');
      return `${index + 1}\t${types}\t${structures}\t${premises}`;
    });
    
    const header = 'Trial\tTypes\tStructures\tPremises';
    const content = [header, ...logData].join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `imagi-world-log-${new Date().toISOString()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Wire up controls
  $('#nback').addEventListener('input', e => {
    state.n = parseInt(e.target.value);
    $('#nbackV').textContent = state.n;
  });

  $('#sec').addEventListener('input', e => {
    state.secondsPerTrial = parseFloat(e.target.value);
    $('#secV').textContent = state.secondsPerTrial;
    $('#secNum').value = state.secondsPerTrial;
  });

  $('#secNum').addEventListener('input', e => {
    state.secondsPerTrial = parseFloat(e.target.value);
    $('#secV').textContent = state.secondsPerTrial;
    $('#sec').value = state.secondsPerTrial;
  });

  $('#premises').addEventListener('input', e => {
    state.premisesPerTrial = parseInt(e.target.value);
    $('#premisesV').textContent = state.premisesPerTrial;
    $('#premisesNum').value = state.premisesPerTrial;
  });

  $('#premisesNum').addEventListener('input', e => {
    state.premisesPerTrial = parseInt(e.target.value);
    $('#premisesV').textContent = state.premisesPerTrial;
    $('#premises').value = state.premisesPerTrial;
  });

  $('#trials').addEventListener('input', e => {
    state.trials = parseInt(e.target.value);
    $('#trialsV').textContent = state.trials;
    $('#trialsNum').value = state.trials;
  });

  $('#trialsNum').addEventListener('input', e => {
    state.trials = parseInt(e.target.value);
    $('#trialsV').textContent = state.trials;
    $('#trials').value = state.trials;
  });

  $('#matchRate').addEventListener('input', e => {
    state.matchRate = parseInt(e.target.value) / 100;
    $('#matchRateV').textContent = e.target.value;
  });

  $('#start').addEventListener('click', startSession);
  $('#stop').addEventListener('click', stopSession);
  $('#reset').addEventListener('click', () => {
    state.score = 0;
    state.hits = 0;
    state.misses = 0;
    state.responses = 0;
    state.omissions = 0;
    updateStats();
    addLog('Statistics reset');
  });
  $('#download').addEventListener('click', exportLog);

  $('#btnMatch').addEventListener('click', () => handleResponse(true));
  $('#btnNoMatch').addEventListener('click', () => handleResponse(false));

  // Keyboard shortcuts
  document.addEventListener('keydown', e => {
    if(!state.running) return;
    
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') {
      e.preventDefault();
      if(!$('#btnMatch').disabled) handleResponse(true);
    }
    if(e.code === 'ArrowRight' || e.code === 'KeyD') {
      e.preventDefault();
      if(!$('#btnNoMatch').disabled) handleResponse(false);
    }
  });

  // Initialize
  updateStats();
  addLog('Imagi-World 2.0 initialized with 62 reasoning types');
})();
</script>
</body>
</html>
