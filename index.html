<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Imagi‑World 2.0 — Single Modality</title>
<style>
  :root{
    --bg:#0b132b;--panel:#1c2541;--ink:#e0e6f3;--accent:#5bc0be;--warn:#ff6b6b;--ok:#2ecc71;--muted:#94a3b8
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
  header{padding:20px 16px;text-align:center;border-bottom:1px solid #223}
  h1{margin:0;font-size:clamp(20px,3vw,28px)}
  .wrap{max-width:1060px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:1fr;gap:16px}
  @media(min-width:880px){.grid{grid-template-columns:320px 1fr}}
  .card{background:var(--panel);border:1px solid #2a335a;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
  .pad{padding:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label span{color:var(--muted);font-size:.9rem}
  input[type=range]{width:100%}
  input[type=number]{width:96px;padding:8px;border-radius:8px;border:1px solid #334;background:#0f1835;color:var(--ink)}
  button{cursor:pointer;border:0;border-radius:10px;padding:10px 14px;font-weight:700}
  .btn{background:var(--accent);color:#062025}
  .btn.secondary{background:#324063;color:#cbd5e1}
  .btn.danger{background:#c0392b;color:white}
  .btn.ghost{background:transparent;border:1px solid #3a466b;color:#cbd5e1}
  .status{font-size:1.15rem;margin:.5rem 0 0;color:#cbd5e1;min-height:1.6lh}
  .premise{font-size:1.45rem;line-height:1.45;min-height:3.2lh;margin:8px 0 0;font-style:italic}
  .bigbtns{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px}
  .bigbtns button{padding:18px 16px;font-size:1.2rem}
  .bigbtns .yes{background:var(--ok);color:#052b16}
  .bigbtns .no{background:var(--warn);color:#2b0505}
  .stats{display:grid;grid-template-columns:repeat(5,minmax(120px,1fr));gap:10px;margin-top:12px}
  .stat{background:#0d1736;border:1px solid #223;border-radius:10px;padding:10px;text-align:center}
  .kpi{font-size:1.6rem;font-weight:800;color:var(--accent)}
  .log{max-height:260px;overflow:auto;background:#081026;border:1px dashed #2a335a;border-radius:10px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.92rem}
  details{background:#101a39;border-radius:10px}
  summary{cursor:pointer;padding:10px 12px;border-bottom:1px solid #202a56}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.92rem}
</style>
</head>
<body>
  <header>
    <h1>Imagi‑World 2.0 · Single‑Modality Stream of 62 Reasoning Types</h1>
    <p class="mono">Default mode only. Premises autogenerate across all 62 types. No pasting required.</p>
  </header>
  <div class="wrap">
    <div class="grid">
      <section class="card pad" aria-label="controls">
        <h2 style="margin-top:0">Session Controls</h2>
        <div class="row">
          <label for="nback">N‑Back Level <span id="nbackV">1</span></label>
        </div>
        <input id="nback" type="range" min="1" max="5" step="1" value="1" />

        <div class="row" style="margin-top:10px">
          <label for="sec">Seconds per trial <span id="secV">8</span></label>
        </div>
        <div class="row">
          <input id="sec" type="range" min="2" max="20" step="0.5" value="8" />
          <input id="secNum" type="number" min="2" max="20" step="0.5" value="8" />
        </div>

        <div class="row" style="margin-top:10px">
          <label for="trials">Trials per session <span id="trialsV">40</span></label>
        </div>
        <div class="row">
          <input id="trials" type="range" min="4" max="1000" step="1" value="40" />
          <input id="trialsNum" type="number" min="4" max="10000" step="1" value="40" />
        </div>

        <div class="row" style="margin-top:10px">
          <label for="matchRate">Target match rate % <span id="matchRateV">30</span></label>
        </div>
        <input id="matchRate" type="range" min="5" max="80" step="1" value="30" />

        <div class="row" style="margin-top:12px">
          <button id="start" class="btn">Start</button>
          <button id="stop" class="btn danger" disabled>Stop</button>
          <button id="reset" class="btn secondary">Reset Stats</button>
          <button id="download" class="btn ghost">Export Log</button>
        </div>
      </section>

      <section class="card pad" aria-live="polite">
        <div class="status" id="status">Ready.</div>
        <div class="premise" id="premise">—</div>
        <div class="bigbtns">
          <button id="btnMatch" class="yes" disabled>Match</button>
          <button id="btnNoMatch" class="no" disabled>No Match</button>
        </div>
        <div class="stats">
          <div class="stat"><div>Trial</div><div class="kpi" id="kTrial">0</div></div>
          <div class="stat"><div>Score</div><div class="kpi" id="kScore">0</div></div>
          <div class="stat"><div>Accuracy</div><div class="kpi" id="kAcc">—</div></div>
          <div class="stat"><div>Omissions</div><div class="kpi" id="kMiss">0</div></div>
          <div class="stat"><div>Matches scheduled</div><div class="kpi" id="kSched">0</div></div>
        </div>
      </section>
    </div>

    <section class="card pad" style="margin-top:16px">
      <details open>
        <summary><strong>How matching works (single modality)</strong></summary>
        <div class="pad">
          <p>Each trial is a <em>novel</em> premise sentence that encodes one of 62 reasoning types. A trial matches at level <span class="mono">n</span> if its hidden signature equals the signature from <span class="mono">n</span> trials earlier after allowed inversions for that type. Matching is never based on string equality.</p>
          <ul>
            <li>No symbols. Only words and letters in the premise.</li>
            <li>Premises are never repeated. A de‑duplication set enforces uniqueness.</li>
            <li>Type selection is random across all 62, while meeting the target match rate.</li>
          </ul>
        </div>
      </details>
      <details>
        <summary><strong>Debug</strong></summary>
        <div class="pad">
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </details>
    </section>
  </div>

<script>
(function(){
  // ---------- utilities ----------
  const $ = sel => document.querySelector(sel);
  const rand = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const choice = arr => arr[rand(0,arr.length-1)];
  const shuffle = arr => { for(let i=arr.length-1;i>0;i--){ const j=rand(0,i); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr }
  const sample = (arr,k)=> shuffle([...arr]).slice(0,k);
  const lettersPool = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  function freshLetters(k, used = new Set()){
    // pick k distinct letters not in used; if exhausted, recycle after clearing
    const avail = [...lettersPool].filter(c=>!used.has(c));
    if(avail.length < k){ used.clear(); return freshLetters(k, used) }
    const pick = sample(avail,k); pick.forEach(c=>used.add(c));
    return pick;
  }
  function sentence(parts){
    // join with proper punctuation
    let s = parts.join('; ').replace(/\s+/g,' ').trim();
    if(!/[.!?]$/.test(s)) s += '.';
    return s;
  }
  function uniqPremise(gen, guardSet){
    for(let i=0;i<999;i++){
      const p = gen();
      if(!guardSet.has(p)){ guardSet.add(p); return p }
    }
    // in pathological case, append a nonce word
    const p = gen()+ ' Again-'+Math.random().toString(36).slice(2,6);
    guardSet.add(p); return p;
  }

  // ---------- signature helpers ----------
  // A signature codes the reasoning type and a normalized structure mask.
  function sig(typeId, mask){ return `${typeId}|${mask}` }

  // letter helpers to create relation phrases without symbols
  const IF = ['if','whenever','whensoever','provided'];
  const THEN = ['then','thereafter','so'];
  const OR = ['or','otherwise'];
  const NOT = ['not','never'];
  const ONLYIF = ['only if','requires'];
  const UNLESS = ['unless'];

  // relation axis phrases used in some types
  const NORTH = ['is north of','sits above','stands over'];
  const SOUTH = ['is south of','sits below','lies under'];
  const EAST = ['is east of','runs alongside','is analogue of'];
  const WEST = ['is west of','opposes','counters'];

  // random grammar bits
  const holds = () => choice(['holds','obtains','is active','is in effect']);
  const absent = () => choice(['is false','is absent','does not hold','fails']);
  const present = () => choice(['is true','holds','is present']);

  // ---------- 62 reasoning types as generators ----------
  // Each returns { premise, signature }
  // The mask is a coarse structure description, independent of letter names and synonyms.

  const usedLetters = new Set();
  function L(k){ return freshLetters(k, usedLetters) }

  const G = {
    // 1 Circularity via drift
    1(){
      const [A,B,C] = L(3);
      const p = sentence([
        `${B} ${choice(NORTH)} ${A}`,
        `some ${C} ${choice(NORTH)} ${B}`,
        `some ${C} ${choice(EAST)} ${A}`
      ]);
      return { premise:p, signature:sig(1,'B>A; some C>B; some C~A') };
    },

    // 2 Modus ponens with decoy disjunction
    2(){
      const [D,E,F] = L(3);
      const p = sentence([
        `${choice(IF)} ${D} ${choice(THEN)} ${E}`,
        `${F} ${choice(OR)} ${D}`,
        `${F} ${absent()}`
      ]);
      return { premise:p, signature:sig(2,'if D then E; F or D; not F') };
    },

    // 3 Modus tollens with inert universal
    3(){
      const [G,H,J] = L(3);
      const p = sentence([
        `${choice(IF)} ${G} ${choice(THEN)} ${H}`,
        `${NOT[0]} ${H}`,
        `for all ${J}, ${J} ${holds()}`
      ]);
      return { premise:p, signature:sig(3,'if G then H; not H; forall J') };
    },

    // 4 Hypothetical syllogism with fork collapse
    4(){
      const [K,L1,M,N] = L(4);
      const p = sentence([
        `${choice(IF)} ${K} ${choice(THEN)} ${L1}`,
        `${choice(IF)} ${L1} ${choice(THEN)} ${M}`,
        `${K} ${choice(OR)} ${N}`,
        `${NOT[0]} ${N}`
      ]);
      return { premise:p, signature:sig(4,'K->L->M; K or N; not N') };
    },

    // 5 Disjunctive syllogism under contradiction
    5(){
      const [P,Q,R] = L(3);
      const p = sentence([
        `${P} ${choice(OR)} ${Q}`,
        `${choice(IF)} ${Q} ${choice(THEN)} ${NOT[0]} ${R}`,
        `${R} ${present()}`
      ]);
      return { premise:p, signature:sig(5,'P or Q; if Q then not R; R') };
    },

    // 6 Constructive dilemma
    6(){
      const [S,T,U,V] = L(4);
      const p = sentence([
        `${choice(IF)} ${S} ${choice(THEN)} ${T}`,
        `${choice(IF)} ${U} ${choice(THEN)} ${V}`,
        `${S} ${choice(OR)} ${U}`
      ]);
      return { premise:p, signature:sig(6,'if S then T; if U then V; S or U') };
    },

    // 7 Destructive dilemma
    7(){
      const [W,X,Y,Z] = L(4);
      const p = sentence([
        `${choice(IF)} ${W} ${choice(THEN)} ${X}`,
        `${choice(IF)} ${Y} ${choice(THEN)} ${Z}`,
        `${NOT[0]} ${X} ${choice(OR)} ${NOT[0]} ${Z}`
      ]);
      return { premise:p, signature:sig(7,'W->X; Y->Z; not X or not Z') };
    },

    // 8 Biconditional by dual construction
    8(){
      const [A,B,C] = L(3);
      const p = sentence([
        `${choice(IF)} ${A} ${choice(THEN)} ${B}`,
        `${choice(IF)} ${B} ${choice(THEN)} ${A}`,
        `${C} is irrelevant`
      ]);
      return { premise:p, signature:sig(8,'A->B & B->A; C junk') };
    },

    // 9 Only-if with contrapositive payoff
    9(){
      const [D,E,H,I] = L(4);
      const p = sentence([
        `${D} ${choice(ONLYIF)} ${E}`,
        `${NOT[0]} ${E}`,
        `${H} ${choice(OR)} ${I}`
      ]);
      return { premise:p, signature:sig(9,'D only-if E; not E; noise') };
    },

    // 10 Unless as inclusive reformulation
    10(){
      const [F,G] = L(2);
      const p = sentence([
        `${F} ${UNLESS[0]} ${G}`,
        `${NOT[0]} ${F}`
      ]);
      return { premise:p, signature:sig(10,'F unless G; not F') };
    },

    // 11 De Morgan with anchored resolution
    11(){
      const [H,I] = L(2);
      const p = sentence([
        `not both ${H} and ${I}`,
        `${H} ${present()}`
      ]);
      return { premise:p, signature:sig(11,'not(H&I); H') };
    },

    // 12 Exportation and importation ladder
    12(){
      const [H,K,L] = L(3);
      const p = sentence([`${H} and ${K} together ensure ${L}`]);
      return { premise:p, signature:sig(12,'(H & K)->L') };
    },

    // 13 Quantifier negation with witness
    13(){
      const [M] = L(1);
      const a = choice(['a','some a','one a']);
      const p = sentence([`not for all x, ${M} of x`, `there exists ${a} with not ${M} of ${a}`]);
      return { premise:p, signature:sig(13,'not forall -> exists not') };
    },

    // 14 Unique existence decomposed
    14(){
      const [N] = L(1);
      const a = choice(['a','u']);
      const p = sentence([`exactly one x has ${N}`, `some ${a} is ${N}`, `any ${N} equals ${a}`]);
      return { premise:p, signature:sig(14,'exists! -> exists & unique') };
    },

    // 15 Quantifier exchange pitfall
    15(){
      const [R] = L(1);
      const x=choice(['x','agent']); const y=choice(['y','token']);
      const p = sentence([`for all ${x} there exists ${y} with ${R}`, `claim there exists ${y} for all ${x}`, `the claim is invalid`]);
      return { premise:p, signature:sig(15,'AxEyR !-> EyAxR') };
    },

    // 16 Quantifier distribution over conjunction
    16(){
      const [A,B] = L(2);
      const p = sentence([`for all x, ${A} and ${B} hold`, `therefore for all x ${A}, and for all x ${B}`]);
      return { premise:p, signature:sig(16,'Ax(A&B)->AxA & AxB') };
    },

    // 17 Modality ladder
    17(){
      const [C,D] = L(2);
      const p = sentence([`must ${C} implies ${D}`, `may ${C} holds`, `${D} remains undetermined`]);
      return { premise:p, signature:sig(17,'must C->D; may C') };
    },

    // 18 Temporal indexing coherence
    18(){
      const [E,F,G] = L(3);
      const p = sentence([`${E} occurs before ${F}`, `${F} implies ${G}`, `later not ${G} observed`, `no contradiction across times`]);
      return { premise:p, signature:sig(18,'E<F; F->G; later not G') };
    },

    // 19 Definition governance
    19(){
      const [H,J,K] = L(3);
      const p = sentence([`define ${H} as exactly ${J}`, `if ${H} then ${K}`, `so ${J} implies ${K}`]);
      return { premise:p, signature:sig(19,'def H==J; H->K => J->K') };
    },

    // 20 Opacity in belief and desire
    20(){
      const [L,M,N] = L(3);
      const p = sentence([`know ${L} equals ${M}`, `believe ${L} has ${N}`, `infer believe ${M} has ${N}?`, `inference invalid`]);
      return { premise:p, signature:sig(20,'substitution blocked in belief') };
    },

    // 21 Comparative with quantifiers
    21(){
      const [P,Q,R] = L(3);
      const p = sentence([`most ${P} are ${Q}`, `all ${Q} are ${R}`, `therefore most ${P} are ${R}`]);
      return { premise:p, signature:sig(21,'most P Q; all Q R => most P R') };
    },

    // 22 Percent versus number integrity
    22(){
      const [S] = L(1);
      const p = sentence([`group one shows a higher percent ${S}`, `group two is much larger`, `no count claim follows from rate alone`]);
      return { premise:p, signature:sig(22,'rate != count') };
    },

    // 23 Simpson reversal
    23(){
      const [A,B] = L(2);
      const p = sentence([`${A} beats ${B} within each stratum`, `strata weights skew`, `overall order can flip`]);
      return { premise:p, signature:sig(23,'Simpson reversal') };
    },

    // 24 Regression to the mean
    24(){
      const [W] = L(1);
      const p = sentence([`extreme ${W} at time one`, `process is stable`, `expect moderation at time two`]);
      return { premise:p, signature:sig(24,'regress to mean') };
    },

    // 25 Numeric tightening with min and max
    25(){
      const [X,Y,Z] = L(3);
      const p = sentence([`exactly three ${X}`, `at least two ${Y} are ${X}`, `at most one ${Z} is ${X}`]);
      return { premise:p, signature:sig(25,'=3 X; >=2 Y in X; <=1 Z in X') };
    },

    // 26 Distribution bounds in sequencing
    26(){
      const [A,B,C,D,E] = L(5);
      const p = sentence([`fixed positions`, `${A} before ${B}`, `${C} not adjacent to ${A}`, `exactly two between ${D} and ${E}`]);
      return { premise:p, signature:sig(26,'seq constraints') };
    },

    // 27 Must-be-true diagnostic
    27(){
      const [A,B,C] = L(3);
      const p = sentence([`${choice(IF)} ${A} ${choice(THEN)} ${B}`, `${choice(IF)} ${B} ${choice(THEN)} ${C}`, `${A} ${present()}`]);
      return { premise:p, signature:sig(27,'A->B->C; A') };
    },

    // 28 Could-be-true diagnostic
    28(){
      const [D,E] = L(2);
      const p = sentence([`${choice(IF)} ${D} ${choice(THEN)} ${E}`, `${NOT[0]} ${D}`, `${E} remains undetermined and could be true`]);
      return { premise:p, signature:sig(28,'D->E; not D => E ?') };
    },

    // 29 Must-be-false diagnostic
    29(){
      const [G,H] = L(2);
      const p = sentence([`not both ${G} and ${H}`, `${H} ${present()}`, `therefore ${G} must be false`]);
      return { premise:p, signature:sig(29,'not(G&H); H => not G') };
    },

    // 30 Necessary assumption detection
    30(){
      const [R,S,T] = L(3);
      const p = sentence([`${R} supports ${S}`, `a hidden bridge from ${T} is required`, `negate the bridge and support collapses`]);
      return { premise:p, signature:sig(30,'negate bridge -> collapse') };
    },

    // 31 Sufficient assumption closure
    31(){
      const [U,V,W] = L(3);
      const p = sentence([`${U} near ${V}`, `we want ${U} implies ${W}`, `known ${V} implies ${W}`, `add ${U} implies ${V}`]);
      return { premise:p, signature:sig(31,'add U->V to get U->W') };
    },

    // 32 Exception precedence
    32(){
      const [A,B,C] = L(3);
      const p = sentence([`all ${A} are ${B} unless ${C}`, `${C} holds`, `${A} holds`, `result: not necessarily ${B}`]);
      return { premise:p, signature:sig(32,'exception overrides rule') };
    },

    // 33 Reductio ad absurdum
    33(){
      const [D,E] = L(2);
      const p = sentence([`assume ${D}`, `derive ${E} and not ${E} under fixed rules`, `therefore not ${D}`]);
      return { premise:p, signature:sig(33,'assume -> contradiction') };
    },

    // 34 Local conditional worlds
    34(){
      const [E,F,G] = L(3);
      const p = sentence([`if ${E} then ${F}`, `if ${F} then ${G}`, `suppose ${E} in a local world`, `so ${G} in the ${E}-world`]);
      return { premise:p, signature:sig(34,'world reasoning chain') };
    },

    // 35 Dominance elimination
    35(){
      const p = sentence([`answer one implies answer two under all rules`, `discard dominated option`, `keep only non‑dominated`]);
      return { premise:p, signature:sig(35,'dominance') };
    },

    // 36 Out-of-scope detection
    36(){
      const [H,J] = L(2);
      const p = sentence([`evidence on ${H}`, `conclusion on unrelated ${J}`, `scope error: missing link`]);
      return { premise:p, signature:sig(36,'scope mismatch') };
    },

    // 37 Role labeling for argument flow
    37(){
      const [K,L,M,N] = L(4);
      const p = sentence([`${K} supports ${L}`, `${M} rebuts ${K}`, `${N} concludes`, `track net toward ${N}`]);
      return { premise:p, signature:sig(37,'roles flow') };
    },

    // 38 Author versus source viewpoint
    38(){
      const [R] = L(1);
      const p = sentence([`author reports: experts say ${R}`, `author rejects ${R}`, `author not committed to ${R}`]);
      return { premise:p, signature:sig(38,'report vs endorse') };
    },

    // 39 Graph reachability with mandatory gate
    39(){
      const [A,B,C,D] = L(4);
      const p = sentence([`${A} connects to ${B}`, `${B} connects to ${C}`, `all paths must pass ${D}`, `${B} avoids ${D}`, `there is no ${A} to ${C} path under the gate`]);
      return { premise:p, signature:sig(39,'must-pass gate blocks path') };
    },

    // 40 Minimal cut-set identification
    40(){
      const [A,B,C,D] = L(4);
      const p = sentence([`routes from ${A} to ${C} use ${B} or ${D}`, `removing both disconnects`, `removing singles does not`, `the set {${B}, ${D}} is minimal`]);
      return { premise:p, signature:sig(40,'minimal cut {B,D}') };
    },

    // 41 Parity invariant under swaps
    41(){
      const p = sentence([`only adjacent swaps allowed`, `initial inversion parity fixed`, `each swap flips parity`, `even flips keep the class`, `unreachable targets flagged`]);
      return { premise:p, signature:sig(41,'parity invariant') };
    },

    // 42 Conservation invariant on totals
    42(){
      const [X,Y] = L(2);
      const p = sentence([`move adds one to ${X} and subtracts one from ${Y}`, `total fixed`, `target raises total and is unreachable`]);
      return { premise:p, signature:sig(42,'conserved sum') };
    },

    // 43 Conditional probability inversion check
    43(){
      const [R,S] = L(2);
      const p = sentence([`many ${R} overall`, `few show ${S}`, `most ${S} are ${R}`, `do not equate chance of ${R} given ${S} with chance of ${S} given ${R}`]);
      return { premise:p, signature:sig(43,'P(R|S) != P(S|R)') };
    },

    // 44 Likelihood‑ratio aggregation
    44(){
      const p = sentence([`two independent signals with stated strength`, `neutral prior`, `combine strengths multiplicatively in odds space`, `posterior tilts by product size`]);
      return { premise:p, signature:sig(44,'LR multiply') };
    },

    // 45 Independence versus exclusivity
    45(){
      const [A,B] = L(2);
      const p = sentence([`events ${A} and ${B} cannot co‑occur`, `claim independence`, `independence holds only in trivial boundary cases`]);
      return { premise:p, signature:sig(45,'exclusive != independent') };
    },

    // 46 Symmetric‑difference algebra
    46(){
      const [A,B,C] = L(3);
      const p = sentence([`${A} differs from ${B} to give ${C}`, `${C} differs from ${B} returns ${A}`]);
      return { premise:p, signature:sig(46,'(A⊕B)⊕B=A (verbal)') };
    },

    // 47 Partial‑order tests
    47(){
      const [a,b,c,d] = L(4);
      const p = sentence([`relation is reflexive and transitive`, `some pair ${a}, ${b} incomparable`, `some pair ${c}, ${d} two‑way comparable so equal`, `partial not total; enforce antisymmetry`]);
      return { premise:p, signature:sig(47,'poset checks') };
    },

    // 48 Minimal hitting‑set for violations
    48(){
      const [X,Y,Z] = L(3);
      const p = sentence([`blockers are any two among three clauses ${X} or ${Y}, ${Y} or ${Z}, ${Z} or ${X}`, `any two‑flag set is minimal`]);
      return { premise:p, signature:sig(48,'hitting set size 2') };
    },

    // 49 Equivalence‑relation partitions
    49(){
      const [E,p] = L(2);
      const ptxt = sentence([`relation is reflexive, symmetric, and transitive`, `class contains ${p}`, `close under relation and separate classes`, `partition by classes`]);
      return { premise: ptxt, signature:sig(49,'equivalence partitions') };
    },

    // 50 Transitive reduction versus closure
    50(){
      const [A,B,C] = L(3);
      const p = sentence([`${A} before ${B}`, `${B} before ${C}`, `${A} before ${C} also listed`, `minimal edges preserve reachability by removing the long edge`]);
      return { premise:p, signature:sig(50,'closure vs reduction') };
    },

    // 51 Minimal countermodel construction
    51(){
      const [D,E] = L(2);
      const p = sentence([`claim all ${D} imply ${E}`, `find ${D} true and ${E} false without breaking rules`, `the universal claim is refuted`]);
      return { premise:p, signature:sig(51,'countermodel') };
    },

    // 52 Inclusion–exclusion bounds
    52(){
      const [F,G] = L(2);
      const p = sentence([`sizes of ${F}, ${G}, and their union known`, `compute overlap as sum minus union`, `bound by zero and minima`]);
      return { premise:p, signature:sig(52,'|F|+|G|-|F∪G| verbal') };
    },

    // 53 Conditional independence via mediation
    53(){
      const [A,B,C] = L(3);
      const p = sentence([`${A} causes ${B}`, `${B} causes ${C}`, `no other links`, `condition on ${B} to block the path, making ${A} independent of ${C}`]);
      return { premise:p, signature:sig(53,'A->B->C, cond on B') };
    },

    // 54 Exchange argument for optimality
    54(){
      const [X,Y] = L(2);
      const p = sentence([`current choice ${X} heavy`, `feasible lighter alternative ${Y} improves value`, `swap to improve while feasible`, `justifies greedy step`]);
      return { premise:p, signature:sig(54,'exchange improves') };
    },

    // 55 Matching and cover duality in bipartite graphs
    55(){
      const p = sentence([`size of best pairing equals size of smallest blocker set`, `build alternating paths to certify equality`]);
      return { premise:p, signature:sig(55,'Kőnig duality verbal') };
    },

    // 56 Submodularity, diminishing returns
    56(){
      const [Z] = L(1);
      const p = sentence([`adding ${Z} to a small set helps more than to a big set`, `compare marginal gains`, `objective is submodular`]);
      return { premise:p, signature:sig(56,'diminishing returns') };
    },

    // 57 Max‑flow equals min‑cut certification
    57(){
      const p = sentence([`all routes cross certain gates`, `a built flow saturates them`, `every path crosses the cut`, `value matches capacity`]);
      return { premise:p, signature:sig(57,'maxflow=mincut verbal') };
    },

    // 58 Adversarial minimax bound
    58(){
      const p = sentence([`planner picks strategy`, `challenger picks case`, `score is worst case`, `adopt the strategy with larger worst case`]);
      return { premise:p, signature:sig(58,'minimax') };
    },

    // 59 Inductive ladder with guarded step
    59(){
      const [K,L] = L(2);
      const p = sentence([`base ${K} holds`, `${K} at level n gives ${L} at level n`, `${L} at level n gives ${K} at level n plus one`, `therefore ${K} holds for every level`]);
      return { premise:p, signature:sig(59,'induction by two‑step') };
    },

    // 60 Augmenting path certification
    60(){
      const p = sentence([`current pairing not maximum if an alternating path starts and ends unmatched`, `flip along the path to increase pairs`]);
      return { premise:p, signature:sig(60,'augmenting path') };
    },

    // 61 Extremal element method
    61(){
      const [P] = L(1);
      const p = sentence([`choose arrangement with smallest cost under rule ${P}`, `any violation allows a cheaper fix`, `therefore the arrangement satisfies all rules`]);
      return { premise:p, signature:sig(61,'extremal argument') };
    },

    // 62 Bijection and inversion
    62(){
      const p = sentence([`mapping is one‑to‑one and onto between two sets`, `build the inverse`, `test injective and surjective parts`, `composition recovers inputs uniquely`]);
      return { premise:p, signature:sig(62,'bijection inverse') };
    },
  };

  const TYPE_IDS = Object.keys(G).map(Number);

  // ---------- session engine ----------
  const state = {
    n:1, sec:8, trials:40, matchRate:0.30,
    running:false, i:0, score:0, hits:0, resp:0, omissions:0,
    schedule:[], // booleans marking whether each index should match n back
    history:[], // {premise, signature}
    guard:new Set(),
    timer:null,
  };

  // schedule matches stochastically while respecting n spacing
  function buildSchedule(n,trials,p){
    const s = Array(trials).fill(false);
    for(let t=n; t<trials; t++){
      s[t] = Math.random() < p;
    }
    return s;
  }

  function nextPremise(){
    // choose a type id uniformly at random
    const typeId = choice(TYPE_IDS);
    const obj = G[typeId]();
    obj.typeId = typeId;
    return obj;
  }

  function makeMatchFrom(historyItem){
    // For matching we reuse the same signature mask and regenerate a fresh sentence of the same type.
    // This keeps matching logical, not textual.
    const typeId = historyItem.typeId;
    let obj = G[typeId]();
    obj.typeId = typeId;
    // Force mask to the earlier mask tag, preserving type equality component.
    obj.signature = sig(typeId, historyItem.signature.split('|')[1]);
    return obj;
  }

  function updateKPI(){
    $('#kTrial').textContent = state.i;
    $('#kScore').textContent = state.score;
    $('#kAcc').textContent = state.resp? Math.round(100*state.hits/state.resp)+'%':'—';
    $('#kMiss').textContent = state.omissions;
    $('#kSched').textContent = state.schedule.filter(Boolean).length;
  }

  function logLine(txt){
    const el = $('#log');
    el.innerHTML = `<div>${new Date().toLocaleTimeString()} · ${txt}</div>` + el.innerHTML;
  }

  function present(){
    if(!state.running) return;
    if(state.i >= state.trials){ stopSession(); return }

    let item;
    const shouldMatch = state.schedule[state.i];
    if(shouldMatch && state.i >= state.n){
      item = makeMatchFrom(state.history[state.i - state.n]);
      logLine(`Scheduled MATCH @${state.i} against ${state.i-state.n} · type ${item.typeId}`);
    } else {
      item = nextPremise();
    }

    // guarantee uniqueness of the rendered sentence
    item.premise = uniqPremise(()=>item.premise, state.guard);

    state.history.push(item);
    $('#premise').textContent = 'Premise: ' + item.premise;
    $('#status').textContent = `Type ${item.typeId} · n-back ${state.n}`;
    $('#btnMatch').disabled = false; $('#btnNoMatch').disabled = false;

    // schedule timeout for omission
    clearTimeout(state.timer);
    state.timer = setTimeout(()=>{
      // omission
      state.omissions++;
      state.resp++;
      const expectMatch = state.schedule[state.i];
      if(expectMatch){ $('#status').textContent = 'Time up · expected MATCH'; }
      else { $('#status').textContent = 'Time up · expected NO MATCH'; }
      state.i++; updateKPI(); present();
    }, state.sec*1000);
  }

  function judge(isMatch){
    if(!state.running) return;
    clearTimeout(state.timer);
    const expectMatch = state.schedule[state.i];
    const correct = (isMatch === expectMatch);
    state.resp++;
    if(correct){ state.score+=1; state.hits+=1; $('#status').textContent = 'Correct' }
    else { state.score-=1; $('#status').textContent = 'Incorrect' }
    state.i++; updateKPI(); present();
  }

  function startSession(){
    state.running = true; state.i=0; state.score=0; state.hits=0; state.resp=0; state.omissions=0; state.history=[]; state.guard.clear();
    state.schedule = buildSchedule(state.n, state.trials, state.matchRate);
    $('#btnMatch').disabled = true; $('#btnNoMatch').disabled = true;
    $('#status').textContent = 'Running…'; $('#premise').textContent = '—';
    present();
    $('#start').disabled = true; $('#stop').disabled = false;
  }
  function stopSession(){ state.running=false; clearTimeout(state.timer); $('#status').textContent='Stopped.'; $('#btnMatch').disabled=true; $('#btnNoMatch').disabled=true; $('#start').disabled=false; $('#stop').disabled=true }

  // ---------- wire UI ----------
  const nR = $('#nback'), nV = $('#nbackV'); nR.addEventListener('input', e=>{ state.n = +e.target.value; nV.textContent = state.n })
  const sR = $('#sec'), sV = $('#secV'), sN=$('#secNum');
  function syncSec(v){ state.sec=+v; sV.textContent=v; sR.value=v; sN.value=v }
  sR.addEventListener('input',e=>syncSec(e.target.value)); sN.addEventListener('input',e=>syncSec(e.target.value));
  const tR=$('#trials'), tV=$('#trialsV'), tN=$('#trialsNum');
  function syncTrials(v){ state.trials=+v; tV.textContent=v; tR.value=v; tN.value=v }
  tR.addEventListener('input',e=>syncTrials(e.target.value)); tN.addEventListener('input',e=>syncTrials(e.target.value));
  const mR=$('#matchRate'), mV=$('#matchRateV'); mR.addEventListener('input',e=>{ state.matchRate=+e.target.value/100; mV.textContent=e.target.value })

  $('#start').addEventListener('click', startSession);
  $('#stop').addEventListener('click', stopSession);
  $('#reset').addEventListener('click', ()=>{ state.score=0; state.hits=0; state.resp=0; state.omissions=0; updateKPI(); $('#status').textContent='Stats reset.' })
  $('#download').addEventListener('click', ()=>{
    const lines = state.history.map((h,i)=>`${i}\tT${h.typeId}\t${h.signature}\t${h.premise}`);
    const blob = new Blob([lines.join('\n')], {type:'text/plain'});
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='imagi-world-2.0-log.txt'; a.click(); URL.revokeObjectURL(a.href);
  })

  $('#btnMatch').addEventListener('click', ()=>judge(true));
  $('#btnNoMatch').addEventListener('click', ()=>judge(false));
  window.addEventListener('keydown', e=>{
    if(!state.running) return;
    if(e.code==='Space'){ e.preventDefault(); judge(true) }
    if(e.code==='Enter'){ e.preventDefault(); judge(false) }
  })

  // init
  syncSec(8); syncTrials(40); updateKPI();
})();
</script>
</body>
</html>
