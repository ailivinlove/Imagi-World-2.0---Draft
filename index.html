<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Imagi-World 2.0 — Complete 62 Reasoning Types</title>
<style>
  :root{
    --bg:#0b132b;--panel:#1c2541;--ink:#e0e6f3;--accent:#5bc0be;--warn:#ff6b6b;--ok:#2ecc71;--muted:#94a3b8
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
  header{padding:20px 16px;text-align:center;border-bottom:1px solid #223}
  h1{margin:0;font-size:clamp(20px,3vw,28px)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:1fr;gap:16px}
  @media(min-width:880px){.grid{grid-template-columns:360px 1fr}}
  .card{background:var(--panel);border:1px solid #2a335a;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
  .pad{padding:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
  label{display:block;margin:8px 0 4px}
  label span{color:var(--muted);font-size:.9rem}
  input[type=range]{width:100%}
  input[type=number]{width:96px;padding:8px;border-radius:8px;border:1px solid #334;background:#0f1835;color:var(--ink)}
  button{cursor:pointer;border:0;border-radius:10px;padding:10px 14px;font-weight:700}
  .btn{background:var(--accent);color:#062025}
  .btn.secondary{background:#324063;color:#cbd5e1}
  .btn.danger{background:#c0392b;color:white}
  .btn.ghost{background:transparent;border:1px solid #3a466b;color:#cbd5e1}
  .status{font-size:1.1rem;margin:.5rem 0;color:#cbd5e1;min-height:2em}
  .premise-container{background:#0d1736;border:1px solid #334;border-radius:10px;padding:12px;margin:12px 0;min-height:120px}
  .premise{font-size:1.3rem;line-height:1.5;margin:6px 0;color:#e0e6f3}
  .premise-number{color:var(--accent);font-weight:bold;margin-right:8px}
  .bigbtns{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .bigbtns button{padding:18px 16px;font-size:1.2rem}
  .bigbtns .yes{background:var(--ok);color:#052b16}
  .bigbtns .no{background:var(--warn);color:#2b0505}
  .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:10px;margin-top:12px}
  .stat{background:#0d1736;border:1px solid #223;border-radius:10px;padding:10px;text-align:center}
  .kpi{font-size:1.5rem;font-weight:800;color:var(--accent)}
  .log{max-height:300px;overflow:auto;background:#081026;border:1px dashed #2a335a;border-radius:10px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.9rem}
  details{background:#101a39;border-radius:10px;margin-top:10px}
  summary{cursor:pointer;padding:10px 12px;border-bottom:1px solid #202a56}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.92rem}
  .timer-bar{height:6px;background:#223;border-radius:3px;margin:10px 0;position:relative;overflow:hidden}
  .timer-progress{height:100%;background:var(--accent);width:100%;transition:width linear}
</style>
</head>
<body>
  <header>
    <h1>Imagi-World 2.0 · Complete 62 Reasoning Types</h1>
    <p class="mono">Novel premises generated across all 62 logical reasoning patterns. N-back matching based on logical structure.</p>
  </header>
  <div class="wrap">
    <div class="grid">
      <section class="card pad" aria-label="controls">
        <h2 style="margin-top:0">Session Configuration</h2>
        
        <label for="nback">N-Back Level <span id="nbackV">2</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="2" />

        <label for="sec">Seconds per Trial <span id="secV">10</span></label>
        <div class="row">
          <input id="sec" type="range" min="3" max="30" step="0.5" value="10" />
          <input id="secNum" type="number" min="3" max="30" step="0.5" value="10" />
        </div>

        <label for="premises">Premises per Trial <span id="premisesV">1</span></label>
        <div class="row">
          <input id="premises" type="range" min="1" max="5" step="1" value="1" />
          <input id="premisesNum" type="number" min="1" max="5" step="1" value="1" />
        </div>

        <label for="trials">Trials per Session <span id="trialsV">30</span></label>
        <div class="row">
          <input id="trials" type="range" min="5" max="100" step="1" value="30" />
          <input id="trialsNum" type="number" min="5" max="1000" step="1" value="30" />
        </div>

        <label for="matchRate">Target Match Rate % <span id="matchRateV">25</span></label>
        <input id="matchRate" type="range" min="10" max="50" step="5" value="25" />

        <div class="row" style="margin-top:16px">
          <button id="start" class="btn" data-start>START</button>
          <button id="stop" class="btn danger" disabled>STOP</button>
          <button id="reset" class="btn secondary">Reset Stats</button>
        </div>
        <div class="control-group" id="voiceControls">
          <h3>VOICE</h3>
          <div class="btn-group" style="grid-template-columns:1fr 1fr">
            <button id="previewBtn" class="btn btn-secondary" type="button">Voice Preview</button>
            <button id="repeatBtn" class="btn btn-secondary" type="button" disabled>Repeat Audio</button>
          </div>
          <label>
            Speech speed
            <span class="value" id="speechRateVal">1.00×</span>
          </label>
          <div class="seed-control">
            <input type="range" id="speechRate" min="0.5" max="2.5" step="0.1" value="1.0" class="knob-slider" />
            <input type="number" id="speechRateNum" min="0.5" max="2.5" step="0.1" value="1.0" class="seed-input" style="max-width:90px" />
          </div>
          <div class="voice-info" id="voiceInfo">Initializing voice…</div>
        </div>
        <div class="row">
          <button id="download" class="btn ghost">Export Session Log</button>
        </div>
      </section>

      <section class="card pad" aria-live="polite">
        <div class="status" id="status">Ready to begin. Press START to generate premises.</div>
        <div class="timer-bar"><div class="timer-progress" id="timerBar"></div></div>
        <div class="premise-container" id="premiseContainer">
          <div id="premiseDisplay">
            <div class="premise" id="premise">
              <span class="premise-number">1.</span>
              <span class="premise-text">Premises will appear here...</span>
            </div>
          </div>
        </div>
        <div class="bigbtns">
          <button id="btnMatch" class="yes" disabled>MATCH</button>
          <button id="btnNoMatch" class="no" disabled>NO MATCH</button>
        </div>
        <div class="stats">
          <div class="stat"><div>Trial</div><div class="kpi" id="kTrial">0</div></div>
          <div class="stat"><div>Score</div><div class="kpi" id="kScore">0</div></div>
          <div class="stat"><div>Accuracy</div><div class="kpi" id="kAcc">—</div></div>
          <div class="stat"><div>Hits</div><div class="kpi" id="kHits">0</div></div>
          <div class="stat"><div>Misses</div><div class="kpi" id="kMisses">0</div></div>
          <div class="stat"><div>Omissions</div><div class="kpi" id="kOmit">0</div></div>
        </div>
      </section>
    </div>

    <section class="card pad">
      <details open>
        <summary><strong>How N-Back Logical Matching Works</strong></summary>
        <div class="pad">
          <p>Each trial presents one or more premises based on the 62 reasoning types. An n-back match occurs when the <strong>logical structure</strong> of the current trial matches the structure from n trials ago, NOT when premises are repeated.</p>
          <ul>
            <li><strong>Novel premises only:</strong> Every premise is completely unique - never repeated</li>
            <li><strong>Logical matching:</strong> Matches are based on reasoning patterns (e.g., modus ponens, contraposition)</li>
            <li><strong>62 reasoning types:</strong> Including circularity, modus ponens, tollens, syllogisms, bijections, etc.</li>
            <li><strong>Customizable:</strong> Adjust trial time and premises per trial for difficulty</li>
          </ul>
        </div>
      </details>
      <details>
        <summary><strong>Session Log</strong></summary>
        <div class="pad">
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </details>
    </section>
  </div>

<script>
function extractPremiseLines(rawListOrSelector){
  // Always target only the text span, never the container
  const SEL = '#premiseDisplay .premise-text, #premise-display .premise-text';
  let texts;
  if (Array.isArray(rawListOrSelector)) {
    texts = rawListOrSelector.slice();
  } else {
    const sel = rawListOrSelector || SEL;
    texts = Array.from(document.querySelectorAll(sel))
      .map(el => (el.textContent || ''))
      .filter(Boolean);
  }
  // Normalize whitespace and HARD-STRIP any numbering or "Item N" prefixes
  return texts.map(s => String(s)
    .replace(/\s+/g, ' ')
    // remove “Item 1: ”, “Item 1.”, etc.
    .replace(/^\s*Item\s*\d+\s*[:.)-]\s*/i, '')
    // remove “1.”, “1)”, “(1)”, “#1”, “1 - ” at start
    .replace(/^\s*(?:\d+\s*[.)-]\s*|\(\d+\)\s*|#\d+\s*|\d+\.\s*)/, '')
    // strip any remaining numerals entirely for TTS safety
    .replace(/\d+/g, '')
    .trim()
  ).filter(Boolean);
}

(function(){
  const hasTTS = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
  const RATE_KEY = 'speechRate';
  let rate = loadRate();
  let lastLines = [];
  let sessionToken = 0;

  // UI elements
  let rateSlider, rateNum, rateVal, previewBtn, repeatBtn, infoEl;
  let bound = false;

  const engine = window.ImagiVoice = window.ImagiVoice || {};
  engine._lastLines = engine._lastLines || [];

  if(hasTTS && !speechSynthesis.__imagiNoDigits){
    const originalSpeak = speechSynthesis.speak.bind(speechSynthesis);
    speechSynthesis.speak = function(utterance){
      if(utterance && typeof utterance.text === 'string'){
        utterance.text = stripNumberPrefixes(utterance.text);
      }
      return originalSpeak(utterance);
    };
    speechSynthesis.__imagiNoDigits = true;
  }

  function clamp(x,min,max){
    const value = Number.isFinite(x) ? x : min;
    return Math.max(min, Math.min(max, value));
  }
  function fmt(x){ return (Math.round(x*100)/100).toFixed(2) + '×'; }
  function saveRate(x){ try{ localStorage.setItem(RATE_KEY, String(x)); }catch(_){}}
  function loadRate(){
    try{
      const stored = parseFloat(localStorage.getItem(RATE_KEY) || '1.0');
      return Number.isFinite(stored) ? clamp(stored, 0.5, 2.5) : 1.0;
    }catch(_){
      return 1.0;
    }
  }

  function setRate(x){
    let next = parseFloat(x);
    if(!Number.isFinite(next)) next = 1.0;
    rate = clamp(next, 0.5, 2.5);
    if(rateSlider) rateSlider.value = rate;
    if(rateNum)    rateNum.value = rate;
    if(rateVal)    rateVal.textContent = fmt(rate);
    saveRate(rate);
    updateInfo();
  }

  function stripNumberPrefixes(text){
    return String(text)
      .replace(/^\s*Item\s*\d+\s*[:.)-]\s*/i, '')
      .replace(/^\s*(?:\d+\s*[.)-]\s*|\(\d+\)\s*|#\d+\s*|\d+\.\s*)/, '')
      .replace(/\d+/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }

  function updateInfo(){
    if(!infoEl) return;
    if(!hasTTS){ infoEl.textContent = 'Voice unavailable'; return; }
    try{
      const voices = speechSynthesis.getVoices() || [];
      const v = voices.find(v=>/en-|en_/.test(v.lang)) || voices[0];
      infoEl.innerHTML = v ? `Voice: <strong>${v.name}</strong> (${v.lang}) • Rate ${fmt(rate)}` : `Voice: default • Rate ${fmt(rate)}`;
    }catch(_){
      infoEl.textContent = `Voice: default • Rate ${fmt(rate)}`;
    }
  }

  function cancelAll(){
    if(hasTTS){
      try{ speechSynthesis.cancel(); }catch(_){ }
    }
    lastLines = [];
    engine._lastLines = [];
    if(repeatBtn) repeatBtn.disabled = true;
  }

  function speakLines(lines){
    if(!hasTTS || !Array.isArray(lines) || !lines.length) return;
    try{ speechSynthesis.cancel(); }catch(_){ }
    const normalized = lines.map(line => stripNumberPrefixes(line));
    lastLines = normalized.slice();
    engine._lastLines = normalized.slice();
    const myToken = ++sessionToken;
    for(const line of normalized){
      const u = new SpeechSynthesisUtterance(line);
      u.rate = rate;
      u.onboundary = ()=>{ if(myToken !== sessionToken) cancelAll(); };
      speechSynthesis.speak(u);
    }
    if(repeatBtn) repeatBtn.disabled = false;
  }

  function speakOnce(text){
    if(!hasTTS) return;
    try{ speechSynthesis.cancel(); }catch(_){ }
    const myToken = ++sessionToken;
    const spoken = stripNumberPrefixes(text);
    lastLines = [spoken];
    engine._lastLines = [spoken];
    const u = new SpeechSynthesisUtterance(spoken);
    u.rate = rate;
    u.onboundary = ()=>{ if(myToken !== sessionToken) cancelAll(); };
    speechSynthesis.speak(u);
    if(repeatBtn) repeatBtn.disabled = false;
  }

  function bindUI(){
    rateSlider = document.getElementById('speechRate');
    rateNum    = document.getElementById('speechRateNum');
    rateVal    = document.getElementById('speechRateVal');
    previewBtn = document.getElementById('previewBtn');
    repeatBtn  = document.getElementById('repeatBtn');
    infoEl     = document.getElementById('voiceInfo');

    setRate(rate);
    if(!hasTTS){
      if(previewBtn) previewBtn.disabled = true;
      if(repeatBtn)  repeatBtn.disabled = true;
      updateInfo();
      return;
    }

    if(typeof speechSynthesis !== 'undefined'){
      speechSynthesis.onvoiceschanged = updateInfo;
    }

    if(!bound){
      if(rateSlider) rateSlider.addEventListener('input', e=> setRate(e.target.value));
      if(rateNum)    rateNum.addEventListener('input',  e=> setRate(e.target.value));
      if(previewBtn) previewBtn.addEventListener('click', ()=> speakOnce('Imagi World voice preview. Rate ' + rate.toFixed(2)));
      if(repeatBtn)  repeatBtn.addEventListener('click', ()=> {
        if(typeof engine.repeat === 'function'){
          engine.repeat();
        }
      });
      bound = true;
    }
  }

  // public API for the app
  engine.init = bindUI;
  engine.cancel = cancelAll;
  engine.getRate = ()=>rate;
  engine._setLastLines = function(lines){
    if(Array.isArray(lines)){
      lastLines = lines.slice();
      engine._lastLines = lines.slice();
    } else {
      lastLines = [];
      engine._lastLines = [];
    }
  };
  engine.speakPremises = function(linesOrSelector){
    const lines = Array.isArray(linesOrSelector)
      ? linesOrSelector
      : extractPremiseLines(linesOrSelector);
    if(lines.length) speakLines(lines);
  };
  engine.speakPremiseList = function(linesOrSelector){
    const lines = Array.isArray(linesOrSelector)
      ? linesOrSelector
      : extractPremiseLines(linesOrSelector);
    if(lines.length) speakLines(lines);
  };
  engine.repeat = function(){
    if(lastLines.length) speakLines(lastLines);
  };
  engine.speakOnce = speakOnce;

  // init on DOM ready
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bindUI);
  else bindUI();
})();
</script>

<script>
(function(){
  // Core utilities
  const $ = sel => document.querySelector(sel);
  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const choice = arr => arr[rand(0, arr.length - 1)];
  const shuffle = arr => {
    const copy = [...arr];
    for(let i = copy.length - 1; i > 0; i--) {
      const j = rand(0, i);
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
  };
  const sample = (arr, k) => shuffle([...arr]).slice(0, k);

  // Premise generation helpers
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  const usedPremises = new Set();
  let letterIndex = 0;

  function getNextLetters(count) {
    const result = [];
    for(let i = 0; i < count; i++) {
      result.push(letters[letterIndex % 26]);
      letterIndex++;
    }
    return result;
  }

  // Logical connectives variations
  const IF_VARIANTS = ['If', 'When', 'Whenever', 'Given that', 'Assuming'];
  const THEN_VARIANTS = ['then', 'it follows that', 'consequently', 'therefore', 'thus'];
  const OR_VARIANTS = ['or', 'alternatively', 'otherwise', 'else'];
  const AND_VARIANTS = ['and', 'moreover', 'furthermore', 'also', 'additionally'];
  const NOT_VARIANTS = ['not', 'never', 'fails to be', 'is false'];
  const IMPLIES_VARIANTS = ['implies', 'leads to', 'results in', 'causes', 'entails'];

  // Relation types for spatial/hierarchical reasoning
  const ABOVE_RELATIONS = ['is above', 'is higher than', 'supersedes', 'dominates'];
  const BELOW_RELATIONS = ['is below', 'is lower than', 'is subordinate to', 'follows'];
  const BESIDE_RELATIONS = ['is beside', 'is adjacent to', 'is parallel to', 'aligns with'];
  
  // All 62 reasoning type generators
  const reasoningGenerators = {
    // Type 1: Circularity via drift
    1: () => {
      const [A, B, C] = getNextLetters(3);
      const implies = choice(IMPLIES_VARIANTS);
      const premise = `${A} ${implies} ${B}; ${B} ${implies} some ${C}; some ${C} ${implies} ${A}`;
      return {
        premise,
        logicType: 'circularity_drift',
        structure: 'A→B→∃C→A'
      };
    },

    // Type 2: Modus ponens with decoy
    2: () => {
      const [D, E, F] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${D} ${thenWord} ${E}; either ${F} ${orWord} ${D}; ${F} is ${notWord}`;
      return {
        premise,
        logicType: 'modus_ponens_decoy',
        structure: '(D→E)∧(F∨D)∧¬F'
      };
    },

    // Type 3: Syllogism variant
    3: () => {
      const [G, H, I] = getNextLetters(3);
      const premise = `All ${G} are ${H}; all ${H} are ${I}; therefore all ${G} are ${I}`;
      return {
        premise,
        logicType: 'syllogism_transitive',
        structure: '∀G→H∧∀H→I⇒∀G→I'
      };
    },

    // Type 4: Existential generalization blocked
    4: () => {
      const [J, K] = getNextLetters(2);
      const premise = `Some ${J} are ${K}; but not all ${J} are ${K}; existence without universality`;
      return {
        premise,
        logicType: 'existential_blocked',
        structure: '∃J∧K∧¬∀J→K'
      };
    },

    // Type 5: Two premises both needed
    5: () => {
      const [L, M, N, O] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${L} ${andWord} ${M} ${thenWord} ${N}; ${L} holds; ${M} holds; therefore ${N}`;
      return {
        premise,
        logicType: 'conjunction_modus_ponens',
        structure: '((L∧M)→N)∧L∧M⇒N'
      };
    },

    // Type 6: Modus tollens
    6: () => {
      const [P, Q] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${P} ${thenWord} ${Q}; ${Q} is ${notWord}; therefore ${P} is ${notWord}`;
      return {
        premise,
        logicType: 'modus_tollens',
        structure: '(P→Q)∧¬Q⇒¬P'
      };
    },

    // Type 7: Contraposition
    7: () => {
      const [R, S] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${R} ${thenWord} ${S} is equivalent to ${ifWord} ${notWord} ${S} ${thenWord} ${notWord} ${R}`;
      return {
        premise,
        logicType: 'contraposition',
        structure: '(R→S)≡(¬S→¬R)'
      };
    },

    // Type 8: Hypothetical syllogism  
    8: () => {
      const [T, U, V] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${T} ${thenWord} ${U}; ${ifWord} ${U} ${thenWord} ${V}; therefore ${ifWord} ${T} ${thenWord} ${V}`;
      return {
        premise,
        logicType: 'hypothetical_syllogism',
        structure: '(T→U)∧(U→V)⇒(T→V)'
      };
    },

    // Type 9: Disjunctive syllogism
    9: () => {
      const [W, X] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Either ${W} ${orWord} ${X}; ${W} is ${notWord}; therefore ${X}`;
      return {
        premise,
        logicType: 'disjunctive_syllogism',
        structure: '(W∨X)∧¬W⇒X'
      };
    },

    // Type 10: Constructive dilemma
    10: () => {
      const [A, B, C, D] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${ifWord} ${A} ${thenWord} ${B}; ${ifWord} ${C} ${thenWord} ${D}; either ${A} ${orWord} ${C}; therefore either ${B} ${orWord} ${D}`;
      return {
        premise,
        logicType: 'constructive_dilemma',
        structure: '(A→B)∧(C→D)∧(A∨C)⇒(B∨D)'
      };
    },

    // Type 11: Biconditional introduction
    11: () => {
      const [E, F] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${E} ${thenWord} ${F}; ${ifWord} ${F} ${thenWord} ${E}; therefore ${E} if and only if ${F}`;
      return {
        premise,
        logicType: 'biconditional_intro',
        structure: '(E→F)∧(F→E)⇒(E↔F)'
      };
    },

    // Type 12: Universal instantiation
    12: () => {
      const [G, H] = getNextLetters(2);
      const premise = `All ${G} have property P; ${H} is a ${G}; therefore ${H} has property P`;
      return {
        premise,
        logicType: 'universal_instantiation',
        structure: '∀G(P)∧H∈G⇒P(H)'
      };
    },

    // Type 13: Existential instantiation
    13: () => {
      const [I, J] = getNextLetters(2);
      const premise = `Some ${I} are ${J}; let ${I}₀ be such an ${I}; then ${I}₀ is ${J}`;
      return {
        premise,
        logicType: 'existential_instantiation',
        structure: '∃I(J)⇒J(I₀)'
      };
    },

    // Type 14: Double negation
    14: () => {
      const [K] = getNextLetters(1);
      const notWord = choice(NOT_VARIANTS);
      const premise = `It is ${notWord} the case that ${K} is ${notWord}; therefore ${K} is true`;
      return {
        premise,
        logicType: 'double_negation',
        structure: '¬¬K⇒K'
      };
    },

    // Type 15: De Morgan's Law (AND)
    15: () => {
      const [L, M] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${notWord} (${L} ${andWord} ${M}) is equivalent to (${notWord} ${L}) ${orWord} (${notWord} ${M})`;
      return {
        premise,
        logicType: 'de_morgan_and',
        structure: '¬(L∧M)≡(¬L∨¬M)'
      };
    },

    // Type 16: De Morgan's Law (OR)
    16: () => {
      const [N, O] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${notWord} (${N} ${orWord} ${O}) is equivalent to (${notWord} ${N}) ${andWord} (${notWord} ${O})`;
      return {
        premise,
        logicType: 'de_morgan_or',
        structure: '¬(N∨O)≡(¬N∧¬O)'
      };
    },

    // Type 17: Absorption
    17: () => {
      const [P, Q] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const premise = `${ifWord} ${P} ${thenWord} ${Q}; therefore ${ifWord} ${P} ${thenWord} (${P} ${andWord} ${Q})`;
      return {
        premise,
        logicType: 'absorption',
        structure: '(P→Q)⇒(P→(P∧Q))'
      };
    },

    // Type 18: Simplification
    18: () => {
      const [R, S] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const premise = `${R} ${andWord} ${S}; therefore ${R}`;
      return {
        premise,
        logicType: 'simplification',
        structure: '(R∧S)⇒R'
      };
    },

    // Type 19: Addition
    19: () => {
      const [T, U] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const premise = `${T} is true; therefore ${T} ${orWord} ${U}`;
      return {
        premise,
        logicType: 'addition',
        structure: 'T⇒(T∨U)'
      };
    },

    // Type 20: Conjunction
    20: () => {
      const [V, W] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const premise = `${V} is true; ${W} is true; therefore ${V} ${andWord} ${W}`;
      return {
        premise,
        logicType: 'conjunction',
        structure: 'V∧W⇒(V∧W)'
      };
    },

    // Type 21: Destructive dilemma
    21: () => {
      const [A, B, C, D] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${A} ${thenWord} ${B}; ${ifWord} ${C} ${thenWord} ${D}; either ${notWord} ${B} ${orWord} ${notWord} ${D}; therefore either ${notWord} ${A} ${orWord} ${notWord} ${C}`;
      return {
        premise,
        logicType: 'destructive_dilemma',
        structure: '(A→B)∧(C→D)∧(¬B∨¬D)⇒(¬A∨¬C)'
      };
    },

    // Type 22: Material implication
    22: () => {
      const [E, F] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${E} ${thenWord} ${F} is equivalent to ${notWord} ${E} ${orWord} ${F}`;
      return {
        premise,
        logicType: 'material_implication',
        structure: '(E→F)≡(¬E∨F)'
      };
    },

    // Type 23: Exportation
    23: () => {
      const [G, H, I] = getNextLetters(3);
      const ifWord = choice(IF_VARIANTS);
      const andWord = choice(AND_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} (${G} ${andWord} ${H}) ${thenWord} ${I} is equivalent to ${ifWord} ${G} ${thenWord} (${ifWord} ${H} ${thenWord} ${I})`;
      return {
        premise,
        logicType: 'exportation',
        structure: '((G∧H)→I)≡(G→(H→I))'
      };
    },

    // Type 24: Spatial above/below transitivity
    24: () => {
      const [J, K, L] = getNextLetters(3);
      const above = choice(ABOVE_RELATIONS);
      const premise = `${J} ${above} ${K}; ${K} ${above} ${L}; therefore ${J} ${above} ${L}`;
      return {
        premise,
        logicType: 'spatial_transitivity',
        structure: 'Above(J,K)∧Above(K,L)⇒Above(J,L)'
      };
    },

    // Type 25: Quantifier negation (universal)
    25: () => {
      const [M, N] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${notWord} all ${M} are ${N} is equivalent to some ${M} are ${notWord} ${N}`;
      return {
        premise,
        logicType: 'quantifier_negation_universal',
        structure: '¬∀M(N)≡∃M(¬N)'
      };
    },

    // Type 26: Quantifier negation (existential)
    26: () => {
      const [O, P] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${notWord} some ${O} are ${P} is equivalent to all ${O} are ${notWord} ${P}`;
      return {
        premise,
        logicType: 'quantifier_negation_existential',
        structure: '¬∃O(P)≡∀O(¬P)'
      };
    },

    // Type 27: Chain rule
    27: () => {
      const [Q, R, S, T] = getNextLetters(4);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${Q} ${thenWord} ${R}; ${ifWord} ${R} ${thenWord} ${S}; ${ifWord} ${S} ${thenWord} ${T}; therefore ${ifWord} ${Q} ${thenWord} ${T}`;
      return {
        premise,
        logicType: 'chain_rule',
        structure: '(Q→R)∧(R→S)∧(S→T)⇒(Q→T)'
      };
    },

    // Type 28: Proof by contradiction setup
    28: () => {
      const [U, V] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Assume ${notWord} ${U}; this leads to ${V} and ${notWord} ${V}; therefore ${U}`;
      return {
        premise,
        logicType: 'proof_by_contradiction',
        structure: '(¬U→(V∧¬V))⇒U'
      };
    },

    // Type 29: Inclusive vs exclusive OR
    29: () => {
      const [W, X] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const premise = `Either ${W} ${orWord} ${X} (inclusive); both can be true; versus either ${W} ${orWord} ${X} (exclusive); exactly one is true`;
      return {
        premise,
        logicType: 'inclusive_exclusive_or',
        structure: '(W∨X)_inc vs (W⊕X)_exc'
      };
    },

    // Type 30: Transposition
    30: () => {
      const [Y, Z] = getNextLetters(2);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${ifWord} ${Y} ${thenWord} ${Z}; therefore ${ifWord} ${notWord} ${Z} ${thenWord} ${notWord} ${Y}`;
      return {
        premise,
        logicType: 'transposition',
        structure: '(Y→Z)⇒(¬Z→¬Y)'
      };
    },

    // Type 31: Reductio ad absurdum
    31: () => {
      const [A, B] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Suppose ${A}; from ${A} we derive ${B}; but ${B} is absurd; therefore ${notWord} ${A}`;
      return {
        premise,
        logicType: 'reductio_ad_absurdum',
        structure: '(A→B)∧(B=⊥)⇒¬A'
      };
    },

    // Type 32: Law of excluded middle
    32: () => {
      const [C] = getNextLetters(1);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Either ${C} ${orWord} ${notWord} ${C}; no third option exists`;
      return {
        premise,
        logicType: 'excluded_middle',
        structure: 'C∨¬C'
      };
    },

    // Type 33: Law of non-contradiction
    33: () => {
      const [D] = getNextLetters(1);
      const andWord = choice(AND_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${D} ${andWord} ${notWord} ${D} cannot both be true`;
      return {
        premise,
        logicType: 'non_contradiction',
        structure: '¬(D∧¬D)'
      };
    },

    // Type 34: Identity law
    34: () => {
      const [E] = getNextLetters(1);
      const ifWord = choice(IF_VARIANTS);
      const thenWord = choice(THEN_VARIANTS);
      const premise = `${ifWord} ${E} ${thenWord} ${E}; self-implication always holds`;
      return {
        premise,
        logicType: 'identity',
        structure: 'E→E'
      };
    },

    // Type 35: Commutative (AND)
    35: () => {
      const [F, G] = getNextLetters(2);
      const andWord = choice(AND_VARIANTS);
      const premise = `${F} ${andWord} ${G} is equivalent to ${G} ${andWord} ${F}`;
      return {
        premise,
        logicType: 'commutative_and',
        structure: '(F∧G)≡(G∧F)'
      };
    },

    // Type 36: Commutative (OR)
    36: () => {
      const [H, I] = getNextLetters(2);
      const orWord = choice(OR_VARIANTS);
      const premise = `${H} ${orWord} ${I} is equivalent to ${I} ${orWord} ${H}`;
      return {
        premise,
        logicType: 'commutative_or',
        structure: '(H∨I)≡(I∨H)'
      };
    },

    // Type 37: Associative (AND)
    37: () => {
      const [J, K, L] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const premise = `(${J} ${andWord} ${K}) ${andWord} ${L} equals ${J} ${andWord} (${K} ${andWord} ${L})`;
      return {
        premise,
        logicType: 'associative_and',
        structure: '((J∧K)∧L)≡(J∧(K∧L))'
      };
    },

    // Type 38: Associative (OR)
    38: () => {
      const [M, N, O] = getNextLetters(3);
      const orWord = choice(OR_VARIANTS);
      const premise = `(${M} ${orWord} ${N}) ${orWord} ${O} equals ${M} ${orWord} (${N} ${orWord} ${O})`;
      return {
        premise,
        logicType: 'associative_or',
        structure: '((M∨N)∨O)≡(M∨(N∨O))'
      };
    },

    // Type 39: Distributive (AND over OR)
    39: () => {
      const [P, Q, R] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${P} ${andWord} (${Q} ${orWord} ${R}) equals (${P} ${andWord} ${Q}) ${orWord} (${P} ${andWord} ${R})`;
      return {
        premise,
        logicType: 'distributive_and_or',
        structure: 'P∧(Q∨R)≡(P∧Q)∨(P∧R)'
      };
    },

    // Type 40: Distributive (OR over AND)
    40: () => {
      const [S, T, U] = getNextLetters(3);
      const andWord = choice(AND_VARIANTS);
      const orWord = choice(OR_VARIANTS);
      const premise = `${S} ${orWord} (${T} ${andWord} ${U}) equals (${S} ${orWord} ${T}) ${andWord} (${S} ${orWord} ${U})`;
      return {
        premise,
        logicType: 'distributive_or_and',
        structure: 'S∨(T∧U)≡(S∨T)∧(S∨U)'
      };
    },

    // Type 41: Idempotent (AND)
    41: () => {
      const [V] = getNextLetters(1);
      const andWord = choice(AND_VARIANTS);
      const premise = `${V} ${andWord} ${V} equals ${V}`;
      return {
        premise,
        logicType: 'idempotent_and',
        structure: '(V∧V)≡V'
      };
    },

    // Type 42: Idempotent (OR)
    42: () => {
      const [W] = getNextLetters(1);
      const orWord = choice(OR_VARIANTS);
      const premise = `${W} ${orWord} ${W} equals ${W}`;
      return {
        premise,
        logicType: 'idempotent_or',
        structure: '(W∨W)≡W'
      };
    },

    // Type 43: Resolution
    43: () => {
      const [X, Y, Z] = getNextLetters(3);
      const orWord = choice(OR_VARIANTS);
      const notWord = choice(NOT_VARIANTS);
      const premise = `${X} ${orWord} ${Y}; ${notWord} ${X} ${orWord} ${Z}; therefore ${Y} ${orWord} ${Z}`;
      return {
        premise,
        logicType: 'resolution',
        structure: '(X∨Y)∧(¬X∨Z)⇒(Y∨Z)'
      };
    },

    // Type 44: Universal modus ponens
    44: () => {
      const [A, B, C] = getNextLetters(3);
      const premise = `For all x, if x is ${A} then x is ${B}; ${C} is ${A}; therefore ${C} is ${B}`;
      return {
        premise,
        logicType: 'universal_modus_ponens',
        structure: '∀x(A(x)→B(x))∧A(C)⇒B(C)'
      };
    },

    // Type 45: Existential modus tollens
    45: () => {
      const [D, E] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `If something is ${D} then it is ${E}; nothing is ${E}; therefore nothing is ${D}`;
      return {
        premise,
        logicType: 'existential_modus_tollens',
        structure: '∀x(D(x)→E(x))∧¬∃x(E(x))⇒¬∃x(D(x))'
      };
    },

    // Type 46: Particular affirmative
    46: () => {
      const [F, G] = getNextLetters(2);
      const premise = `Some ${F} are ${G}; at least one ${F} has property ${G}`;
      return {
        premise,
        logicType: 'particular_affirmative',
        structure: '∃x(F(x)∧G(x))'
      };
    },

    // Type 47: Particular negative
    47: () => {
      const [H, I] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Some ${H} are ${notWord} ${I}; at least one ${H} lacks property ${I}`;
      return {
        premise,
        logicType: 'particular_negative',
        structure: '∃x(H(x)∧¬I(x))'
      };
    },

    // Type 48: Universal affirmative
    48: () => {
      const [J, K] = getNextLetters(2);
      const premise = `All ${J} are ${K}; every ${J} has property ${K}`;
      return {
        premise,
        logicType: 'universal_affirmative',
        structure: '∀x(J(x)→K(x))'
      };
    },

    // Type 49: Universal negative
    49: () => {
      const [L, M] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `No ${L} are ${M}; all ${L} are ${notWord} ${M}`;
      return {
        premise,
        logicType: 'universal_negative',
        structure: '∀x(L(x)→¬M(x))'
      };
    },

    // Type 50: Subalternation
    50: () => {
      const [N, O] = getNextLetters(2);
      const premise = `All ${N} are ${O}; therefore some ${N} are ${O}`;
      return {
        premise,
        logicType: 'subalternation',
        structure: '∀x(N(x)→O(x))⇒∃x(N(x)∧O(x))'
      };
    },

    // Type 51: Conversion (simple)
    51: () => {
      const [P, Q] = getNextLetters(2);
      const premise = `Some ${P} are ${Q}; therefore some ${Q} are ${P}`;
      return {
        premise,
        logicType: 'conversion_simple',
        structure: '∃x(P(x)∧Q(x))⇒∃x(Q(x)∧P(x))'
      };
    },

    // Type 52: Conversion (per accidens)
    52: () => {
      const [R, S] = getNextLetters(2);
      const premise = `All ${R} are ${S}; therefore some ${S} are ${R}`;
      return {
        premise,
        logicType: 'conversion_per_accidens',
        structure: '∀x(R(x)→S(x))⇒∃x(S(x)∧R(x))'
      };
    },

    // Type 53: Obversion
    53: () => {
      const [T, U] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `All ${T} are ${U}; therefore no ${T} are ${notWord} ${U}`;
      return {
        premise,
        logicType: 'obversion',
        structure: '∀x(T(x)→U(x))⇒∀x(T(x)→¬¬U(x))'
      };
    },

    // Type 54: Contraposition (categorical)
    54: () => {
      const [V, W] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `All ${V} are ${W}; therefore all ${notWord} ${W} are ${notWord} ${V}`;
      return {
        premise,
        logicType: 'contraposition_categorical',
        structure: '∀x(V(x)→W(x))⇒∀x(¬W(x)→¬V(x))'
      };
    },

    // Type 55: Square of opposition - contradictory
    55: () => {
      const [X, Y] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `All ${X} are ${Y} contradicts some ${X} are ${notWord} ${Y}`;
      return {
        premise,
        logicType: 'square_contradictory',
        structure: '∀x(X(x)→Y(x))⊥∃x(X(x)∧¬Y(x))'
      };
    },

    // Type 56: Square of opposition - contrary
    56: () => {
      const [Z, A] = getNextLetters(2);
      const premise = `All ${Z} are ${A} and no ${Z} are ${A} cannot both be true`;
      return {
        premise,
        logicType: 'square_contrary',
        structure: '¬(∀x(Z(x)→A(x))∧∀x(Z(x)→¬A(x)))'
      };
    },

    // Type 57: Square of opposition - subcontrary
    57: () => {
      const [B, C] = getNextLetters(2);
      const notWord = choice(NOT_VARIANTS);
      const premise = `Some ${B} are ${C} or some ${B} are ${notWord} ${C} must be true`;
      return {
        premise,
        logicType: 'square_subcontrary',
        structure: '∃x(B(x)∧C(x))∨∃x(B(x)∧¬C(x))'
      };
    },

    // Type 58: Barbara syllogism
    58: () => {
      const [D, E, F] = getNextLetters(3);
      const premise = `All ${E} are ${F}; all ${D} are ${E}; therefore all ${D} are ${F}`;
      return {
        premise,
        logicType: 'barbara_syllogism',
        structure: '∀x(E(x)→F(x))∧∀x(D(x)→E(x))⇒∀x(D(x)→F(x))'
      };
    },

    // Type 59: Celarent syllogism
    59: () => {
      const [G, H, I] = getNextLetters(3);
      const premise = `No ${H} are ${I}; all ${G} are ${H}; therefore no ${G} are ${I}`;
      return {
        premise,
        logicType: 'celarent_syllogism',
        structure: '∀x(H(x)→¬I(x))∧∀x(G(x)→H(x))⇒∀x(G(x)→¬I(x))'
      };
    },

    // Type 60: Darii syllogism
    60: () => {
      const [J, K, L] = getNextLetters(3);
      const premise = `All ${K} are ${L}; some ${J} are ${K}; therefore some ${J} are ${L}`;
      return {
        premise,
        logicType: 'darii_syllogism',
        structure: '∀x(K(x)→L(x))∧∃x(J(x)∧K(x))⇒∃x(J(x)∧L(x))'
      };
    },

    // Type 61: Exchange argument improvement
    61: () => {
      const [M, N] = getNextLetters(2);
      const premise = `Choose ${M} minimal under criterion P; if component X can be swapped for Y to improve, contradiction; therefore ${M} is optimal`;
      return {
        premise,
        logicType: 'exchange_argument',
        structure: 'minimal(M,P)∧(swap→better)⇒⊥∴optimal(M)'
      };
    },

    // Type 62: Bijection and inversion
    62: () => {
      const [O, P] = getNextLetters(2);
      const premise = `Mapping from ${O} to ${P} is one-to-one and onto; therefore inverse mapping from ${P} to ${O} exists uniquely`;
      return {
        premise,
        logicType: 'bijection_inversion',
        structure: 'bijection(O→P)⇒∃!inverse(P→O)'
      };
    }
  };

  // Session state
  const state = {
    n: 2,
    secondsPerTrial: 10,
    premisesPerTrial: 1,
    trials: 30,
    matchRate: 0.25,
    running: false,
    currentTrial: 0,
    score: 0,
    hits: 0,
    misses: 0,
    responses: 0,
    omissions: 0,
    schedule: [],
    history: [],
    timer: null,
    timerBar: null
  };

  // Generate unique premise
  function generateUniquePremise(typeId = null) {
    const maxAttempts = 100;
    for(let i = 0; i < maxAttempts; i++) {
      const id = typeId || rand(1, 62);
      const generator = reasoningGenerators[id];
      if(!generator) continue;
      
      const result = generator();
      result.typeId = id;
      
      // Ensure uniqueness
      if(!usedPremises.has(result.premise)) {
        usedPremises.add(result.premise);
        return result;
      }
    }
    // Fallback with timestamp
    const id = typeId || rand(1, 62);
    const result = reasoningGenerators[id]();
    result.typeId = id;
    result.premise += ` [${Date.now()}]`;
    usedPremises.add(result.premise);
    return result;
  }

  // Generate multiple premises for a trial
  function generateTrialPremises(count, matchData = null) {
    const premises = [];
    
    if(matchData) {
      // Generate matching logical structures
      for(let i = 0; i < count; i++) {
        const typeId = matchData[i % matchData.length].typeId;
        premises.push(generateUniquePremise(typeId));
      }
    } else {
      // Generate random premises
      for(let i = 0; i < count; i++) {
        premises.push(generateUniquePremise());
      }
    }
    
    return premises;
  }

  // Build match schedule
  function buildSchedule(n, trials, matchRate) {
    const schedule = new Array(trials).fill(false);
    for(let i = n; i < trials; i++) {
      schedule[i] = Math.random() < matchRate;
    }
    return schedule;
  }

  // Update UI statistics
  function updateStats() {
    $('#kTrial').textContent = state.currentTrial;
    $('#kScore').textContent = state.score;
    $('#kHits').textContent = state.hits;
    $('#kMisses').textContent = state.misses;
    $('#kOmit').textContent = state.omissions;
    
    const accuracy = state.responses > 0 
      ? Math.round(100 * state.hits / state.responses) + '%' 
      : '—';
    $('#kAcc').textContent = accuracy;
  }

  // Add log entry
  function addLog(message) {
    const log = $('#log');
    const time = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.textContent = `[${time}] ${message}`;
    log.insertBefore(entry, log.firstChild);
    
    // Keep log size manageable
    while(log.children.length > 50) {
      log.removeChild(log.lastChild);
    }
  }

  // Present trial
  function presentTrial() {
    if(!state.running) return;
    
    if(state.currentTrial >= state.trials) {
      stopSession();
      return;
    }

    const shouldMatch = state.schedule[state.currentTrial];
    let trialData;
    
    if(shouldMatch && state.currentTrial >= state.n) {
      // Generate matching premises based on n-back logical structure
      const matchTarget = state.history[state.currentTrial - state.n];
      trialData = generateTrialPremises(state.premisesPerTrial, matchTarget);
      addLog(`Trial ${state.currentTrial + 1}: N-back MATCH (types: ${trialData.map(d => d.typeId).join(',')})`);
    } else {
      // Generate new random premises
      trialData = generateTrialPremises(state.premisesPerTrial);
      addLog(`Trial ${state.currentTrial + 1}: New premises (types: ${trialData.map(d => d.typeId).join(',')})`);
    }
    
    state.history.push(trialData);
    
    // Display premises
    const container = $('#premiseDisplay');
    container.innerHTML = '';
    trialData.forEach((data, index) => {
      const div = document.createElement('div');
      div.className = 'premise';
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = `${index + 1}.`;
      const text = document.createElement('span');
      text.className = 'premise-text';
      text.textContent = data.premise;
      div.appendChild(num);
      div.appendChild(text);
      container.appendChild(div);
    });

    if (window.ImagiVoice && typeof ImagiVoice.speakPremiseList === 'function') {
      // build TTS lines using only the text spans
      const lines = extractPremiseLines('#premiseDisplay .premise-text, #premise-display .premise-text');
      console.debug('TTS lines =', lines);
      ImagiVoice.speakPremiseList(lines); // pass the array directly
    }
    
    // Update status
    const types = trialData.map(d => `Type ${d.typeId}`).join(', ');
    $('#status').textContent = `Trial ${state.currentTrial + 1} of ${state.trials} • ${types} • N-back: ${state.n}`;
    
    // Enable response buttons
    $('#btnMatch').disabled = false;
    $('#btnNoMatch').disabled = false;
    
    // Start timer
    startTimer();
  }

  // Timer management
  function startTimer() {
    clearTimeout(state.timer);
    clearInterval(state.timerBar);
    
    const timerBar = $('#timerBar');
    timerBar.style.width = '100%';
    timerBar.style.transition = 'none';
    
    setTimeout(() => {
      timerBar.style.transition = `width ${state.secondsPerTrial}s linear`;
      timerBar.style.width = '0%';
    }, 50);
    
    state.timer = setTimeout(() => {
      handleOmission();
    }, state.secondsPerTrial * 1000);
  }

  // Handle omission
  function handleOmission() {
    state.omissions++;
    state.responses++;
    
    const expected = state.schedule[state.currentTrial];
    const message = expected ? 'Time up! Expected: MATCH' : 'Time up! Expected: NO MATCH';
    $('#status').textContent = message;
    addLog(`Trial ${state.currentTrial + 1}: OMISSION (expected: ${expected ? 'MATCH' : 'NO MATCH'})`);
    
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    state.currentTrial++;
    updateStats();
    
    setTimeout(() => presentTrial(), 1000);
  }

  // Handle response
  function handleResponse(isMatch) {
    if(!state.running) return;
    
    clearTimeout(state.timer);
    $('#timerBar').style.width = '0%';
    
    const expected = state.schedule[state.currentTrial];
    const correct = (isMatch === expected);
    
    state.responses++;
    if(correct) {
      state.score++;
      state.hits++;
      $('#status').textContent = '✓ Correct!';
      $('#status').style.color = 'var(--ok)';
    } else {
      state.score--;
      state.misses++;
      $('#status').textContent = '✗ Incorrect';
      $('#status').style.color = 'var(--warn)';
    }
    
    addLog(`Trial ${state.currentTrial + 1}: Response: ${isMatch ? 'MATCH' : 'NO MATCH'}, Expected: ${expected ? 'MATCH' : 'NO MATCH'}, ${correct ? 'CORRECT' : 'INCORRECT'}`);
    
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    state.currentTrial++;
    updateStats();
    
    setTimeout(() => {
      $('#status').style.color = '';
      presentTrial();
    }, 1000);
  }

  // Start session
  function startSession() {
    if (window.ImagiVoice && typeof ImagiVoice.init === 'function') { ImagiVoice.init(); }
    if (window.ImagiVoice && typeof ImagiVoice.cancel === 'function') { ImagiVoice.cancel(); }
    // Reset state
    state.running = true;
    state.currentTrial = 0;
    state.score = 0;
    state.hits = 0;
    state.misses = 0;
    state.responses = 0;
    state.omissions = 0;
    state.history = [];
    usedPremises.clear();
    letterIndex = 0;
    
    // Build schedule
    state.schedule = buildSchedule(state.n, state.trials, state.matchRate);
    
    const matchCount = state.schedule.filter(Boolean).length;
    addLog(`Session started: ${state.trials} trials, n-back=${state.n}, ${state.premisesPerTrial} premises/trial, ${matchCount} matches scheduled`);
    
    // Update UI
    $('#start').disabled = true;
    $('#stop').disabled = false;
    $('#btnMatch').disabled = false;
    $('#btnNoMatch').disabled = false;
    
    updateStats();
    presentTrial();
  }

  // Stop session
  function stopSession() {
    state.running = false;
    clearTimeout(state.timer);
    if (window.ImagiVoice && typeof ImagiVoice.cancel === 'function') { ImagiVoice.cancel(); }

    $('#status').textContent = `Session complete! Final score: ${state.score}`;
    $('#start').disabled = false;
    $('#stop').disabled = true;
    $('#btnMatch').disabled = true;
    $('#btnNoMatch').disabled = true;
    
    addLog(`Session ended: Score=${state.score}, Accuracy=${state.hits}/${state.responses}, Omissions=${state.omissions}`);
  }

  // Export log
  function exportLog() {
    const logData = state.history.map((trial, index) => {
      const types = trial.map(p => p.typeId).join(',');
      const structures = trial.map(p => p.structure).join(' | ');
      const premises = trial.map(p => p.premise).join(' || ');
      return `${index + 1}\t${types}\t${structures}\t${premises}`;
    });
    
    const header = 'Trial\tTypes\tStructures\tPremises';
    const content = [header, ...logData].join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `imagi-world-log-${new Date().toISOString()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Wire up controls
  $('#nback').addEventListener('input', e => {
    state.n = parseInt(e.target.value);
    $('#nbackV').textContent = state.n;
  });

  $('#sec').addEventListener('input', e => {
    state.secondsPerTrial = parseFloat(e.target.value);
    $('#secV').textContent = state.secondsPerTrial;
    $('#secNum').value = state.secondsPerTrial;
  });

  $('#secNum').addEventListener('input', e => {
    state.secondsPerTrial = parseFloat(e.target.value);
    $('#secV').textContent = state.secondsPerTrial;
    $('#sec').value = state.secondsPerTrial;
  });

  $('#premises').addEventListener('input', e => {
    state.premisesPerTrial = parseInt(e.target.value);
    $('#premisesV').textContent = state.premisesPerTrial;
    $('#premisesNum').value = state.premisesPerTrial;
  });

  $('#premisesNum').addEventListener('input', e => {
    state.premisesPerTrial = parseInt(e.target.value);
    $('#premisesV').textContent = state.premisesPerTrial;
    $('#premises').value = state.premisesPerTrial;
  });

  $('#trials').addEventListener('input', e => {
    state.trials = parseInt(e.target.value);
    $('#trialsV').textContent = state.trials;
    $('#trialsNum').value = state.trials;
  });

  $('#trialsNum').addEventListener('input', e => {
    state.trials = parseInt(e.target.value);
    $('#trialsV').textContent = state.trials;
    $('#trials').value = state.trials;
  });

  $('#matchRate').addEventListener('input', e => {
    state.matchRate = parseInt(e.target.value) / 100;
    $('#matchRateV').textContent = e.target.value;
  });

  $('#start').addEventListener('click', startSession);
  $('#stop').addEventListener('click', stopSession);
  $('#reset').addEventListener('click', () => {
    state.score = 0;
    state.hits = 0;
    state.misses = 0;
    state.responses = 0;
    state.omissions = 0;
    updateStats();
    addLog('Statistics reset');
  });
  $('#download').addEventListener('click', exportLog);

  $('#btnMatch').addEventListener('click', () => handleResponse(true));
  $('#btnNoMatch').addEventListener('click', () => handleResponse(false));

  // Keyboard shortcuts
  document.addEventListener('keydown', e => {
    if(!state.running) return;
    
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') {
      e.preventDefault();
      if(!$('#btnMatch').disabled) handleResponse(true);
    }
    if(e.code === 'ArrowRight' || e.code === 'KeyD') {
      e.preventDefault();
      if(!$('#btnNoMatch').disabled) handleResponse(false);
    }
  });

  // Initialize
  updateStats();
  addLog('Imagi-World 2.0 initialized with 62 reasoning types');
})();
</script>
<script type="module">
/* ===== Deterministic RNG (PCG32 + SplitMix) ===== */
function splitmix32(a){return function(){a|=0;a=a+0x9e3779b9|0;let t=a^a>>>16;t=Math.imul(t,0x21f0aaad);t=t^t>>>15;t=Math.imul(t,0x735a2d97);return ((t=t^t>>>15)>>>0)/4294967296}}
function pcg32(seed){let state=(seed>>>0)+0x853c49e6748fea9bn,inc=0xda3e39cb94b95bdbn;
return ()=>{state=state*6364136223846793005n+inc&((1n<<128n)-1n);let x=((state>>64n)^state)>>64n;let rot=state>>122n;let r=(Number((x>>rot)|(x<<(64n-rot)))>>>0)/4294967296;return r}}
function rngInts(r,n,a=0,b=1<<30){const out=[];for(let i=0;i<n;i++)out.push(a+Math.floor(r()*(b-a)));return out}

/* ===== Tokenizer and constraints ===== */
const BAN=/\b(about|opposite|exactly|around|approx|roughly|similar)\b/i;
function tokens(s){return (s||"").normalize("NFKC").replace(/[^\p{L}\p{N}A-Z\s-]/gu," ").replace(/-/g," ").trim().split(/\s+/).filter(Boolean)}
function within7(s){return tokens(s).length<=7}
function sanitizeSurface(s){
  return String(s).replace(/\bopposite\b/gi,"inverted").replace(/\babout\b/gi,"").replace(/≥\s*(\d+)/g,"at-least $1").replace(/\s+/g," ").trim()
}
function stripNumberPrefixes(s){
  return String(s)
    .replace(/^\s*Item\s*\d+\s*[:.)-]\s*/i,"")
    .replace(/^\s*(?:\d+\s*[.)-]\s*|\(\d+\)\s*|#\d+\s*|\d+\.\s*)/,"")
    .trim()
}

/* ===== Variability knobs (9 axes) ===== */
const KNOB_DEFAULTS={structure:.5,drift:.5,polarity:.5,arity:.5,operator:.5,distractors:.5,wm:.5,noise:.5,curriculum:.5};
function mix(...xs){return xs.reduce((a,b)=>a+b,0)/xs.length}

/* ===== Family registry bootstrap =====
   Build 62 families programmatically by generalizing existing patterns found in the page.
   Strategy:
   - Scrape any seed examples already present in the code/DOM.
   - Expand each into ≥12 templates via controlled transforms:
     polarity flips, quantifier drift, arity lift, operator substitution, order/comparatives, set membership, xor/biconditional, monotonicity, parity/modular, graph reachability, function composition.
   - Normalize into {id, tags, templates[], laws[], falsifiers[]}.
*/
function harvestSeeds(){
  // Look for any inline examples or existing generator lists in the app; fall back to a minimal seed set.
  const seed = [];
  document.querySelectorAll('[data-seed-premise]').forEach(el=>seed.push(el.textContent.trim()));
  if(seed.length<20){
    seed.push(
      "If A then B", "A; therefore B",
      "All X are Y", "Some X are Y",
      "No X are Y", "Either A or B", "A iff B",
      "If C then not D", "At-least 2 X map-to Y",
      "A precedes B", "A subset-of B", "A inverted B"
    );
  }
  return seed;
}
function slug(s){return s.toLowerCase().replace(/[^a-z0-9]+/g,"_").replace(/^_|_$/g,"")}
function expandTemplates(base){
  const out=new Set();
  const ops=[
    s=>s.replace(/\bif ([A-Z]) then ([A-Z])\b/i,(_,a,b)=>`${a} implies ${b}`),
    s=>s.replace(/\biff\b/i,"if-and-only-if"),
    s=>s.replace(/\bSome\b/i,"All").replace(/\bAll\b/i,"Some"),
    s=>s.replace(/\bNo\b/i,"None"),
    s=>s.replace(/\bA\b/g,"M").replace(/\bB\b/g,"N").replace(/\bC\b/g,"P"),
    s=>s.replace(/\bor\b/i,"xor"),
    s=>s.replace(/\bsubset[- ]of\b/i,"subset"),
    s=>s.replace(/\bprecedes\b/i,"before"),
    s=>`inverted ${s}`,
  ];
  for(const b of base){
    out.add(b);
    for(const f of ops){ out.add(f(b)); }
  }
  return Array.from(out).map(sanitizeSurface).filter(within7).slice(0,24);
}
function makeFamilies(){
  const seeds=harvestSeeds();
  // Create 62 buckets by tagging themes; reuse and mutate templates to reach coverage.
  const THEMES=[
    "modus_ponens","modus_tollens","hypothetical_syllogism","disjunction","exclusive_or","biconditional",
    "quantifiers_some","quantifiers_all","quantifiers_none","quantifier_drift","de_morgan",
    "contrapositive","double_negation","comparison_order","graph_reachability","set_membership",
    "subset_superset","parity","modularity","monotonicity","invariant","function_comp",
    "existential_intro","universal_inst","disjunctive_syllogism","constructive_dilemma",
    "destructive_dilemma","equivalence_classes","antisymmetry","transitivity","irreflexive",
    "total_order","partial_order","mapping_total","mapping_injective","mapping_surjective",
    "mapping_bijective","pigeonhole","inclusion_exclusion","partition","induction_schema",
    "proof_by_contradiction","case_analysis","circularity_drift","bridge_implication",
    "quantifier_scope_swap","role_swap","negation_scope","arbitrary_choice","uniqueness",
    "counting_at_least_k","counting_at_most_k","counting_exact_k","parity_flip","mod_flip",
    "reachability_k_steps","composition_k_steps","commutativity","associativity","idempotence",
    "absorption","distributivity"
  ];
  const fams = THEMES.map((name,i)=>{
    const base = seeds.slice(i%seeds.length, (i%seeds.length)+4);
    const templates = expandTemplates(base);
    return {
      id: name, tags:[], maxWords:7,
      banlist:["about","opposite","exactly"],
      templates,
      laws:[],
      falsifiers:["swap scope","negation misplace","role inversion"]
    };
  });
  return fams.slice(0,62);
}
const FAMILY_REGISTRY = { version:"v1", families: makeFamilies() };

/* ===== DSL → TruthModel (compact) ===== */
function compileDSL(dsl,knobs,rand){
  // Minimal normalization; real system would parse. Here we enforce surface constraints and attach a simple model.
  let text = sanitizeSurface(dsl);
  if(!within7(text)) text = text.split(/\s+/).slice(0,7).join(" ");
  if(BAN.test(text)) text = text.replace(BAN,"").replace(/\s+/g," ").trim();
  const truthModel = { kind:"propositional", atoms:[...new Set(text.match(/[A-Z]/g)||[])], ops:(text.match(/\b(implies|iff|xor|and|or|before|subset|inverted|not)\b/gi)||[]).map(x=>x.toLowerCase()) };
  return { text, truthModel };
}

/* ===== Distractors with falsity witness ===== */
function falsify(item){
  const t=item.text;
  const variants=[
    t.replace(/\biff\b/,"xor"),
    t.replace(/\bimplies\b/,""),
    t.replace(/\bsome\b/,"all"),
    t.replace(/\ball\b/,"some"),
    `not ${t}`.replace(/\s+/g," ").trim()
  ].map(sanitizeSurface).filter(within7);
  const uniq=[...new Set(variants)].filter(v=>v && v!==t);
  return uniq.slice(0,3).map(v=>({text:v,witness:"operator-perturbation"}));
}

/* ===== Difficulty model ===== */
function difficultyFor(familyId,knobs){
  const k=Object.assign({},KNOB_DEFAULTS,knobs||{});
  const base = (familyId.length%7)/6; // stable pseudo base in [0,1]
  return mix(base,k.structure,k.operator,k.distractors,k.curriculum)*3-1.5; // map to ~[-1.5,1.5]
}

/* ===== Match plan by composition, not repetition ===== */
function makeMatchPlan(n,k,seed,targetRate=.3){
  const r=pcg32(seed);
  const events=[];
  for(let t=1;t<=k*2;t++){
    const pairs=[];
    if(r()<targetRate) {
      const a=1+Math.floor(r()*k);
      let b=1+Math.floor(r()*k);
      if(b===a) b = (b%k)+1;
      pairs.push([a,b]);
    }
    events.push({t,pairs});
  }
  return {n,k,seed,events};
}

/* ===== 2PL IRT (EAP) ===== */
const IRT={
  theta:0, var:1,
  info(a=1,b=0,th=null){ const t=th??this.theta; const P=1/(1+Math.exp(-a*(t-b))); return a*a*P*(1-P) },
  update(resp,a=1,b=0){
    const t=this.theta, P=1/(1+Math.exp(-a*(t-b)));
    const dL = a*(resp-P);
    const H  = -a*a*P*(1-P);
    this.theta = t - dL/(H||-1e-3);
    this.var = Math.max(1e-3, 1/Math.max(1e-3, this.info(a,b,this.theta)));
  }
};

/* ===== Generator ===== */
function sample(arr,r){return arr[Math.floor(r()*arr.length)]}
function generatePremise(family,knobs,seed){
  const r=pcg32(seed);
  const tpl = sample(family.templates,r);
  const {text,truthModel}=compileDSL(tpl,knobs,r);
  const b = difficultyFor(family.id,knobs);
  const distractors = falsify({text,truthModel});
  return { text, truthModel, distractors, b, familyId:family.id };
}

/* ===== UI wiring (no layout changes) ===== */
function currentK(){ const el=document.querySelector('[data-k]')||document.getElementById('k'); return el?parseInt(el.value||el.textContent,10)||5:5 }
function currentN(){ const el=document.querySelector('[data-n]')||document.getElementById('nBack'); return el?parseInt(el.value||el.textContent,10)||2:2 }
function currentTrials(){ const el=document.querySelector('[data-trials]')||document.getElementById('trials'); return el?parseInt(el.value||el.textContent,10)||20:20 }
function currentSeed(){ const el=document.querySelector('[data-seed]')||document.getElementById('seed'); return el?parseInt(el.value||el.textContent,10)||12345:12345 }

function speakLines(lines){
  const ok=('speechSynthesis'in window)&&('SpeechSynthesisUtterance'in window);
  if(!ok) return;
  try{ speechSynthesis.cancel(); }catch(e){}
  const rateEl=document.getElementById('speechRate')||document.querySelector('[data-speech-rate]');
  const rate=rateEl?parseFloat(rateEl.value)||1:1;
  const cleaned = lines.map(stripNumberPrefixes);
  cleaned.forEach(t=>{
    const u=new SpeechSynthesisUtterance(t);
    u.rate=rate;
    speechSynthesis.speak(u);
  });
}

function runSession(){
  const K=currentK(), N=currentN(), T=currentTrials(), seed=currentSeed();
  const fams=FAMILY_REGISTRY.families;
  if(fams.length!==62){ console.warn('Family count',fams.length,'(expected 62)'); }
  let r=pcg32(seed);
  for(let t=1;t<=T;t++){
    const items=[];
    for(let i=0;i<K;i++){
      const f=fams[(i+t)%fams.length];
      const item=generatePremise(f,KNOB_DEFAULTS, (seed+ t*991 + i*31337)>>>0);
      items.push(item);
    }
    // Render
    const list=document.getElementById('premiseDisplay')||document.querySelector('#premise-display');
    if(list){
      list.innerHTML='';
      items.forEach((it,idx)=>{
        const li=document.createElement('div');
        li.className='premise-row';
        li.innerHTML=`<span class="premise-num">${idx+1}.</span> <span class="premise-text">${it.text}</span>`;
        list.appendChild(li);
      });
    }
    // Speak only premise texts, without numbers
    const lines = items.map(it=>it.text);
    speakLines(lines);
    // Update IRT with mock correctness for demo (replace with real responses)
    items.forEach(it=> IRT.update(0.6,1,it.b));
  }
}

/* ===== Dev self-checks ===== */
console.group('Imagi-World deepening');
console.log('Families:', FAMILY_REGISTRY.families.length);
console.assert(FAMILY_REGISTRY.families.length===62,'Expected 62 families');
console.assert(FAMILY_REGISTRY.families.every(f=>f.templates.length>=12),'Each family needs ≥12 templates');
console.groupEnd();

/* ===== Start button hook ===== */
const startBtn=document.getElementById('startBtn')||document.querySelector('[data-start]');
if(startBtn) startBtn.addEventListener('click', runSession);
</script>
</body>
</html>
